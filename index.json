[{"categories":[],"content":"魔鬼藏在細節中","date":"2020-12-03","objectID":"/20201203-javascript-traps/","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"最近面試了幾間公司，才發現自己在 javascript 一些細節的基礎知識實在不夠扎實，實在汗顏 所以此篇文章應該會陸續加入自己看過或遇到過的 javascript 坑，並大至簡單的說明其原因 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:0:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"0.1 + 0.2 != 0.3 console.log(0.1 + 0.2); // 0.30000000000000004 javascript 進行計算前需要先把浮點數轉化為二進位數 但當 0.1 轉為二進制時，為 0.0001 1001 1001… 的無限循環小數 而 javascript 浮點數計算最多支持到第52位小數 捨去52位後的小數然後計算，計算結果再轉為10進位小數 就得到了最後這個有誤差的結果了 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:1:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"[3,5,7,11].sort() [3,5,7,11].sort(); // [11, 3, 5, 7] 因為 javascript 默認使用字典序(alphanumeric)來排序。 欲正確排序的話，應該改寫為 [3, 5, 7, 11].sort( (a,b) =\u003e a-b ) ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:2:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt parseInt(3, 10); // 3 parseInt(3, 0); // 3 parseInt(3, 8); // 3 parseInt(3, 2); // NAN parseInt(3, 37); // NAN ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:3:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt：函式說明 parseInt 的第一個參數為數字或字串，第二個參數為 radix 基數 其運作方式是先將第一個參數轉為字串 然後以第二個參數為基數解析第一個參數 回傳第一個參數的十進位的值，如： parseInt(101, 2) = parseInt(“101”, 2) = 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 4 + 0 + 1 = 5 parseInt(‘2F’, 16) = 2 * 16^1 + 15 * 16^0 = 32 + 15 = 47 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:3:1","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt：問題1: 傳入0為基數 如果 第二個參數(radix) 給的是 0，則其效果同傳入預設值 10 所以 parseInt(3, 0) 會等於 parseInt(3, 10) ，結果自然就是 3 了 然而 radix 的預設值可能會因為特殊的執行情境而有不是10的情況 所以使用這個函式時建議還是明確加上第二個參數 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:3:2","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt：問題2: 不合法的表示法會回傳 NAN parseInt(3, 2) 是 NAN 的原因是，在 2 進制表示法中，應該只會出現 0 和 1 才對 如：1011010，意即，2進制的表示法中，不可能出現大於等於2的數字 所以 parseInt(3, 2) 因為出現了3，所以結果就是 NAN 了 同理 parseInt(5, 5) 也會是 NAN， 因為 5進制的表示法應該是如：402314，會出現的最大數字是4 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:3:3","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt：問題3: 基數的上下限 第二個參數radix是有範圍限制的，就是不能大於36，也不能小於 2 當傳入基數大於36，或小於2時(0除外)，回傳NaN ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:3:4","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt 延伸問題 [1, 2, 3].map(parseInt); // [1, NaN, NaN] 先了解一下 array.map 的參數： array.map(callback(currentValue, index, array), this) currentValue: 各陣列 item 值，以上例來說，依序會是 1, 2, 3 index: 各陣列 item 索引，以上例來說，依序會是 0, 1, 2 故該程式碼的執行就會是如下： parseInt(1, 0); // 同 parseInt(1, 10) =\u003e 1 parseInt(2, 1); // radix \u003c 2 =\u003e NaN parseInt(3, 2); // 2 進制的表示法不會有大於等於2的數字 =\u003e NaN ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:4:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"Math.min() \u003e Math.max() Math.min() \u003c Math.max() // false Math.min() \u003e 0 // true Math.max() \u003e 0 // false Math.max() 回傳 -Infinity Math.min() 回傳 Infinity ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:5:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"參考資料： https://juejin.cn/post/6847902225872879630 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:6:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"解決 api routes authentication 問題","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"之前一直有遇到一個問題是經由 routes/api.php 的路由怎麼樣也無法取得 Auth::user() 的資料 也無法做出正確的使用者驗證，此篇針對此問題紀錄解決方案與問題原因 ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:0:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"了解 Middleware groups middleware 中介層，為 HTTP request 進入 Controller 之前的中間過濾/處理器 middleware groups 也就是一組中介層，套用該 middleware groups 的路由需依序進行各中介層的檢查 Laravel 的 middleware groups 預設有兩組，web 與 api \u003c?php // app/Http/Kernel.php protected $middlewareGroups = [ // web middleware group 'web' =\u003e [ // ... \\Illuminate\\Session\\Middleware\\StartSession::class, // ... \\App\\Http\\Middleware\\VerifyCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], // api middleware group 'api' =\u003e [ 'throttle:api', // 對照下面的 $routeMiddleware 可知為執行 ThrottleRequests 並以 api 為參數 \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], ]; protected $routeMiddleware = [ // ... 'throttle' =\u003e \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, ]; 套用 web 的 route 會依序執行：StartSession, VerifyCsrfToken, SubstituteBindings 等 middleware 套用 api 的 route 會依序執行:ThrottleRequests(以 ‘api’ 為參數) 和 SubstituteBindings 兩個 middleware 並且由 RouteServiceProvider 可知： routes/api.php 預設使用 api middleware group routes/web.php 預設使用 web middleware group \u003c?php // app/Providers/RouteServiceProvider.php /** * Define your route model bindings, pattern filters, etc. * * @return void */ public function boot() { $this-\u003econfigureRateLimiting(); $this-\u003eroutes(function () { Route::prefix('api') -\u003emiddleware('api') -\u003enamespace($this-\u003enamespace) -\u003egroup(base_path('routes/api.php')); Route::middleware('web') -\u003enamespace($this-\u003enamespace) -\u003egroup(base_path('routes/web.php')); }); } ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:1:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"了解 Authenticate guards Laravel 預設的 authenticate guards 也有兩組，用來決定以什麼樣的方式進行使用者驗證 取了同樣的名稱，一個是 web，一個是 api 為了必免與 middleware group 混淆，以下稱為 web guard、api guard web guard 的 driver 是 session， api guard 的 driver 是 token \u003c?php // config/auth.php 'guards' =\u003e [ // web guard 'web' =\u003e [ 'driver' =\u003e 'session', 'provider' =\u003e 'users', ], // api guard 'api' =\u003e [ 'driver' =\u003e 'token', 'provider' =\u003e 'users', 'hash' =\u003e false, ], ], ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:2:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"分析為何無法在 api routes 驗證使用者 在 routes/api.php 預設的內容如下 \u003c?php Route::middleware('auth:api')-\u003eget('/user', function (Request $request) { return $request-\u003euser(); }); 嘗試 fetch 這個 api，或是改成 Route::middleware('auth:web')，卻都返回 {message: 'Unauthenticated'} 有兩層原因，一個是 session 問題，一個是 token 設定問題 如果要通過使用者認證，一定要通過任一個 authenticate guard web guard 是透過 session 認證，api guard 是透過 token 驗證 session 問題 =\u003e 不能使用 web guard 無法使用web guard，意即不能採取Route::middleware('auth:web')的方式 原因是 routes/api.php 預設使用 api middleware group，其中的中介層中沒有經過 StartSession 所以就算選擇使用 web guard，也會因為沒有 session 可以取得而認證失敗 事實上 laravel 官方也不建議讓 api 路由再藉由 session 的方式做使用者認證，應該採取較嚴謹的 token 做法 所以在 routes/api.php 的預設程式碼才會看到預設傳給 auth middleware 的認證護衛是 api guard token 設定問題 =\u003e 需額外設定 但如果使用 api guard，就必須做好 token 相對應的設定 而 token 驗證的方式太多元，laravel 並沒有預先配置好任一種方式 而很多開發者，可能都把 api routes 寫到 web.php，走 web middleware、web guard，一樣以 session 做認證 所以官方就將這部份作為一個進階彈性的設定選項，沒有預設載入這部分的配置 簡言之，官方預設： routes/web.php 走 web middleware group，有經過 StartSession，可以使用 web guard 以 session 驗證 routes/api.php 走 api middleware group，沒經過 StartSession，只能使用 api guard 以 token 驗證 但是 token 驗證的方式請自行搞定 ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:3:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"配置 token authentication ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"核心邏輯 其實 token 驗證的核心邏輯很簡單，就是給 users 資料表加上一個 api_token 的欄位， 並且在 request 的時候，也要傳入該 token 的值 比方說，現在已登入的使用者，其紀錄在資料表中對應的 api_token 是 a9lkjw7eoruosdvlaskjerioudoj... 那發出的 api request 就要傳入一樣的 token axios.get('api/...', { params: { api_token: 'a9lkjw7eoruosdvlaskjerioudoj...' } }) 至於為什麼是要加上 api_token 這個欄位，是參考自官方文件的說明 (https://laravel.com/docs/5.8/api-authentication#introduction) ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:1","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"步驟 0： 確認預設設定 確認 api guard 使用 token driver \u003c?php // config/auth.php 'guards' =\u003e [ 'web' =\u003e [ 'driver' =\u003e 'session', 'provider' =\u003e 'users', ], 'api' =\u003e [ 'driver' =\u003e 'token', 'provider' =\u003e 'users', 'hash' =\u003e false, ], ], ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:2","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"步驟 1： 新增 api_token 欄位 php artisan make:migration add_api_token_to_users \u003c?php use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; class AddApiTokenToUsers extends Migration { public function up() { Schema::table('users', function (Blueprint $table) { $table-\u003estring('api_token', 60) -\u003eunique() -\u003enullable() -\u003edefault(null) -\u003eafter('password'); }); } public function down() { Schema::table('users', function (Blueprint $table) { $table-\u003edropColumn('api_token'); }); } } php artisan migrate ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:3","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"步驟 2：於登入時產生 api token 註冊 login listener php artisan make:listener SuccessLogin \u003c?php // app/Listeners/SuccessLogin.php namespace App\\Listeners; use Illuminate\\Contracts\\Queue\\ShouldQueue; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Support\\Facades\\Auth; use Illuminate\\Support\\Str; class SuccessLogin { public function handle($event) { $user = Auth::user(); $user-\u003eapi_token = Str::random(60); $user-\u003esave(); } } 於 EventServiceProvider 加入 listener \u003c?php // app/Providers/EventServiceProvider.php namespace App\\Providers; // ... use App\\Listeners\\SuccessLogin; use Illuminate\\Auth\\Events\\Login; class EventServiceProvider extends ServiceProvider { protected $listen = [ // ... Login::class =\u003e [ SuccessLogin::class, ] ]; } ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:4","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"步驟 3：使 axios 預設帶入 token 將 api token 與 csrf token 放到 meta tag 上 \u003cmeta name=\"csrf-token\" content=\"{{ csrf_token() }}\"\u003e @auth \u003cmeta name=\"api-token\" content=\"{{ Auth::user()-\u003eapi_token }}\"\u003e @endauth 將 api token 與 csrf token 設定到 axios 的 header // bootstrap.js window.axios = require('axios'); window.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest'; const csrfMetaTag = document.querySelector('meta[name=\"csrf-token\"]'); csrfMetaTag ? window.axios.defaults.headers.common['X-CSRF-TOKEN'] = csrfMetaTag.getAttribute('content') : console.log('csrf token not found'); const apiMetaTag = document.querySelector('meta[name=\"api-token\"]'); apiMetaTag ? window.axios.defaults.headers.common['Authorization'] = \"Bearer \" + apiMetaTag.getAttribute('content') : console.log('api token not found'); ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:5","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"步驟 4：完成 確認 routes/api.php 預設內容 \u003c?php // routes/api.php Route::middleware('auth:api')-\u003eget('/user', function (Request $request) { return $request-\u003euser(); }); 進行測試： // app.js axios.get('http://127.0.0.1:8000/api/user').then(res =\u003e { console.log(res); }); 重新登入應該就可以看到 log 出 axios 回傳的 user data 了解 ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:6","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"結語 上述的步驟 2 和 3 的方式是參考自 這篇文章 的做法 雖然這樣的做法還是將 api token 放到 meta tag 上了，但每次登入都會進行 token 的代換 已經可以算是最簡單的方式 如果要再更嚴謹的話，應該是要建立一個 controller 更新 token 再將 token 傳回給前端框架使用，或是存到 window.localStorage \u003c?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Str; use Illuminate\\Http\\Request; class ApiTokenController extends Controller { /** * Update the authenticated user's API token. * * @param \\Illuminate\\Http\\Request $request * @return array */ public function update(Request $request) { $token = Str::random(60); $request-\u003euser()-\u003eforceFill([ 'api_token' =\u003e hash('sha256', $token), // 這邊用 hash 的話，config/auth.php 的 hash 設定就要改成 true ])-\u003esave(); return ['token' =\u003e $token]; } } 但就如前面所說，token驗證的方式實在有很多種方式， 只要了解其核心邏輯，開發者其實可以自行決定要怎麼做， 希望這篇文章有幫助到和我遇到一樣問題的人 ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:5:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"參考資料 https://learnku.com/articles/11006/detailed-explanation-of-laravels-own-api-guard-drive-token https://learnku.com/docs/laravel/5.8/api-authentication/3952 https://laravel.com/docs/5.8/api-authentication#introduction https://caloskao.org/laravel-api-token-usage/ ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:6:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"慣例優於設定 Convention over configuration","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"命名常常是令人最頭痛的環節，一個專案中沒有統一的命名規則，可能會造成開發上的疑惑， 本文參考官方文件，簡單整理了在 Laravel 中幾個命名慣例的規則 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:0:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"命名的方式 camelCase 小駝鋒式命名 snake_case 蛇行命名 PascalCase (pascal 是一門程式語言) 或稱 大駝鋒式命名 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:1:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"約定優於配置(Convention over configuration) 定義 約定優於配置(CoC)，或稱「慣例優於設定」 是一種軟體設計範式，旨在減少軟體開發人員需做決定的數量，獲得簡單的好處，而又不失靈活性 開發者只需設定偏離約定的項目 例如，當 Ｍodel 名為 Sale 時，則對應的資料表默認(約定)為 sales 也就是 Model 的 $table 屬性預設為 sales 只有在偏離這一約定時，例如將資料表命名為 “products_sold”，才需覆寫 Model 的 $table 屬性 為 “products_sold” \u003c?php // Sale Model class Sale extends Model { // 預設值為 sales，覆寫為 products_sold protected $table=\"products_sold\" } 而這樣只需對偏離約定的項目進行設定的概念就是所謂的 約定優於配置 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:2:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"Laravel Mdel / table / Seeder 命名慣例 下表第一列是命名對象，第二列紅字列代表命名規則，再往下則是範例 Model table Seeder、Factory PascalCase、單數 snake_case、複數 PascalCase、單數、'Seeder/Factory'為結尾 Post posts PostSeeder / PostFactory Mybook my_books MybookSeeder / MybookFactory Laravel 底層取得默認 $table 值的邏輯可在 Illuminate\\Database\\Eloquent\\Model 的 getTable() 找到 若沒有設定 $table 屬性，它會利用 Illuminate\\Support\\Pluralizer 來取得複數的名詞 這個 Pluralizer 可能比我們預想的都要來的強大，包含以 y 結尾的單字、常見的不可數名詞都能順利轉換 如：Person =\u003e people, Category =\u003e categories, Series =\u003e series, Information =\u003e information… 不管如何，為保守起見，還是可以設定一下 $table 屬性 \u003c?php // Category Model class Category extends Model { // 雖然預設應該就會是 categories，但還是可以習慣設定一下 protected $table=\"categories\" } ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:3:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"Pivot table 的命名 設兩資料表 products 與 features 是透過一個 pivot (中介資料表) 來進行多對多的關聯 則該 pivot 的默認名稱為 feature_product，命名的規則是：依字母排序的單數名詞、snake_case 若希望 pivot 命名為 product_feature_maps，則需在兩個對應的 Model 中設定如下 (加入第二個參數，pivot name) \u003c?php // in Product model public function features() { return $this-\u003ebelongsToMany('App\\Feature', 'product_feature_maps'); } // in Feature model public function products() { return $this-\u003ebelongsToMany('App\\Product', 'product_feature_maps'); } 個人覺得 product_feature_maps 這樣的命名可以讓語意更加明顯 不過官方預設命名為 feature_product 也不是沒有道理 因為當大部份資料表都依慣例被取名為複數的時候，單數命名的資料表應該就是 pivot table 了 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:4:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"Primary/Foreign Key 命名方式 範例 Primary key 一律命名為 id id Foreign key 來源資料表單數名詞 + _id post_id ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:5:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"\u0008結論： 保守為避免出錯可以都設定一下 Model 的 $table 屬性、belongsToMany 的第二參數 當然命名規則最好能盡量符合官方文件的慣例，至少要統一一個規範 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:6:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"\u0008參考資料： 維基百科-約定優於配置(CoC) Laravel 项目开发规范 Laravel 的十八個最佳實踐 為你自己學 Laravel - Day 12 Model 與資料表 Laravel 官方文件 - eloquent-model-conventions stackoverflow-Pivot table 的命名 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:7:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":["laravelPlugins"],"content":"New authentication scaffolding for laravel 8","date":"2020-10-28","objectID":"/20201028-jetstream/","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"5 commands save you 5 days in 5 minutes Laravel Jetstream 是隨著 Laravel 8.x 一同釋出的新套件 同樣由 Laravel 之父 Taylor Otwell 所開發 它提供了登入、註冊、信箱驗證、雙重驗證、Session管理等功能 可以快速為新專案提供一個好的開始 本篇簡述安裝 Jetstream 的過程 ","date":"2020-10-28","objectID":"/20201028-jetstream/:0:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"建立專案 laravel new jetstream-demo laravel 8.x 支援在建立專案時就選擇載入 jetstream，指令如下 laravel new project-name --jet 若沒有在建立專案時就選擇載入 jetstream，循下文用 composer 再 require 進來即可 ","date":"2020-10-28","objectID":"/20201028-jetstream/:1:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"安裝 Jetstream Jetstream 提供 livewire 與 inertia 兩種 frontend stacks (我不知道怎麼翻，就翻\"特殊前端框架\"吧) 安裝 Jetstream 時必須 2 擇 1 ，這裡選擇安裝 livewire 而不管選哪一個，開發時都可以選擇是否使用，或是局部使用 我目前只知道 livewire 好像是 for 對前端框架不那麼熟悉的後端開發者所做的工具 而 inertia 像是可以在 laravel 這個框架上更舒適的使用 Vue.js 詳細教學可以查看官方文件(livewire / inertia) 安裝 Jetstream 的指令如下： composer require laravel/jetstream php artisan jetstream:install livewire 因為 jetstream 它包含了上述框架與 tailwindcss(比 Bootstrap 更有彈性的css架構)，所以安裝好它會提示你要執行以下指令 來將上述框架的 js, css 一起打包到 public/css/app.css 與 public/css/app.js npm install \u0026\u0026 npm run dev ","date":"2020-10-28","objectID":"/20201028-jetstream/:2:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"設定資料庫 在本機端建一個名為 jetstream 的資料庫，並設定 .env DB_CONNECTION=mysql DB_HOST=127.0.0.1 DB_PORT=3306 DB_DATABASE=jetstream DB_USERNAME=root DB_PASSWORD= ","date":"2020-10-28","objectID":"/20201028-jetstream/:3:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"執行 migration php artisan migrate 到目前為止就算部署完成了，相當簡單，可以執行 php artisan serve 就會看到首頁右上角多了 Login 與 Register 的按扭 並且註冊、登入等功能也真的可以正常運作 真的是 5 commands save you 5 days in 5 minutes (而且大部份時間都在等安裝而已) XD ","date":"2020-10-28","objectID":"/20201028-jetstream/:4:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"(optional)設定 public disk link 如果有用到 jetstream 上傳圖片的功能，可能會遇到上傳的圖片破圖的問題，以下為相關說明： config/filesystems.php (檔案系統設定) 紀錄所有磁碟（disk）的設定 每個磁碟設定對應一組儲存驅動與儲存位置(預設有 local, public, s3 三個磁碟設定) 其中 public disk 理論上是要放「能被公開存取的檔案」 但 public disk 預設將檔案存到 storage/app/public，這個位置是無法被公開存取的 (整個網站公開對外的資料夾為 public) 故需執行以下指令，在 public 產生一個 storage 的捷徑，如此 jetstream 上傳的照片就能夠被存取到了 php artisan storage:link 總之就是執行上行指令就對了，對於這個指令的詳細說明可以再參考 Laravel 之有關 storage:link 路徑設置 或 官方說明 ","date":"2020-10-28","objectID":"/20201028-jetstream/:5:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"參考資料 Jetstream 官方文件 Laravel 8 官方文件 Laravel Installer 4.0 更新小記 什麼是 Inertia.js 什麼是 Laravel Jetstream 用 Livewire 在 Laravel 應用裡實現無痛的前後端溝通 ","date":"2020-10-28","objectID":"/20201028-jetstream/:6:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":[],"content":"Vue component name-casing","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"命名的方式 my-first-component kebab-case (串燒) myFirstComponent camelCase (駝鋒) MyFirstComponent PascalCase (pascal 是一門程式語言) ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:1:0","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"宣告組件的命名沒有限制 可以使用三種命名的任一種 Vue.component('my-first-component', { /* ... */ }) // or Vue.component('myFirstComponent', { /* ... */ }) // or Vue.component('MyFirstComponent', { /* ... */ }) ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:2:0","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"模版的命名 ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:3:0","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"用 HTML 作為 View 的模版 只能用 kebab-case 不能 self closing (一定要加上 closing tag \u003c/my-first-component\u003e) \u003cmy-first-component\u003e\u003c/my-first-component\u003e ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:3:1","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"用 template 作為模版 不管宣告時的命名方式，皆可以用 kebab-case 也可以用 camelCase 或 PascalCase，但須與宣告的命名方式相同 (如：都是camelCase) 可以 self closing Vue.component('my-first-component', { /* ... */ }) // or Vue.component('myFirstComponent', { /* ... */ }) // or Vue.component('MyFirstComponent', { /* ... */ }) new Vue({ el: '#app', template: ` \u003cdiv\u003e \u003cmy-first-component/\u003e \u003c/div\u003e `, }) Vue.component('myFirstComponent', { /* ... */ }) new Vue({ el: '#app', template: ` \u003cdiv\u003e \u003cmyFirstComponent/\u003e \u003c/div\u003e `, }) Vue.component('MyFirstComponent', { /* ... */ }) new Vue({ el: '#app', template: ` \u003cdiv\u003e \u003cMyFirstComponent/\u003e \u003c/div\u003e `, }) ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:3:2","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"結論 均使用 kebab-case 準沒錯 template模版可以 self closing，HTML模版不行 宣告組件的命名沒有限制 HTML模版必用 kebab-case，template 模版可以使用同宣告組件的命名方式 ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:4:0","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"參考資料 Vue 官方網站 精通 VueJS 前端開發完全指南 ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:5:0","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":["tdd"],"content":"我的第一支 php 測試程式","date":"2020-10-09","objectID":"/20201009-phpunit-note/","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":" PHPUnit 是 PHP編程語言的單元測試框架。 本文從最簡單的範例，說明 PHPUnit 的使用方法 我的電腦環境 OS: macOS 10.15.7 php: 7.3.22 composer: 1.9.2 ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:0:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"1. 建立測試專案 \u0008建立專案資料夾並安裝最新版的 phpunit take php-tdd-demo composer require phpunit/phpunit 這裡我們並不是全域安裝 phpunit，而是在這個專案下可以透過 ./vendor/bin/phpunit 來執行 phpunit 例如執行以下指令查看 phpunit 版本 ./vendor/bin/phpunit --version 建立 src, tests 資料夾 mkdir src tests 此時我們的資料夾結構就如下： 📂 src 我們的來源php程式碼(要被測試的程式)放在這裡 📂 tests 測試程式將被放到這裡來 📂 vendor composer.json composer.lock 在 composer.json 加上以下設定： \"autoload\": { \"psr-4\": { \"Src\\\\\": \"src/\" } }, \"autoload-dev\": { \"psr-4\": { \"Tests\\\\\": \"tests/\" } } ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:1:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"2. 建立我的第一支測試程式 在 tests/ 資料夾新增一個檔案 CalculatorTest.php touch tests/CalculatorTest.php Tip 所有可被執行的測試程式檔案必須取名為 XxxTest.php ！(以Test為結尾，大駝峰式命名) 在 tests/CalculatorTest.php 寫入： \u003c?php use PHPUnit\\Framework\\TestCase; use Src\\Calculator; class CalculatorTest extends TestCase { public function testAdd() { /** @Arange */ $calculator = new Calculator(); $expected = 2; /** @Act */ $actual = $calculator-\u003eadd(1, 1); /** @Assert */ $this-\u003eassertEquals($expected, $actual); } } Tip 所有測試程式需要 extends TestCase 測試函式名稱取為 testXxxx ！(以test為開頭，小駝峰式命名) 在 testAdd 函式中，以3A原則撰寫測試： Arange：準備好要被測試的資料 =\u003e $calculator 計算器物件、預期值 2 Act：調用受測物件的方法 =\u003e 計算器物件傳入兩個1，回傳相加的結果 Assert：驗證是否符合預期 =\u003e 驗證回傳之結果是否符合預期值 2 ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:2:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"3. 執行測試 輸入以下指令會執行 tests/ 資料夾底下符合測試命名規則的所有測試 ./vendor/bin/phpunit tests 可以加入 --testdox 來顯示測試名稱、 --colors 使顯示的結果有顯色 ./vendor/bin/phpunit tests --testdox --colors 結果： 紅燈！出現了 Class 'Tests\\Calculator' not found 的錯誤，因為我們還沒開始寫 Calculator 物件 ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:3:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"4. 開始實作 Calculator 與 add 方法 建立 src/Calculator.php 並寫入： \u003c?php namespace Src; class Calculator { public function add($a, $b) { return $a + $b; } } ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:4:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"5. 再次執行測試程式 執行 ./vendor/bin/phpunit tests --testdox --colors 結果： 綠燈！完成！ ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:5:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"參考資料 TDD 範例三：用 PHPUnit 改寫範例二 PHPUnit 官方網站 程式碼： https://github.com/hdsbook/php-tdd-demo ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:6:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["modernWeb"],"content":"Laravel Mix 提供了一個優雅的 API 來為你的專案設定 Webpack","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":" Laravel Mix 提供了一個優雅的 API 來為你的專案設定 Webpack 許多人在入門 Webpack 的時候一定和小弟一樣會遇到一個瓶頸， 就是覺得 webpack.config.js 不知道怎麼設定！ 沒有人手把手帶的話實在要花很多時間去理解它的設定規則… Laravel mix 提供一系列優雅的 api，讓你可以更直觀的做 webpack 的設定， 真的是降低了很大的 webpack 使用門檻！ ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:0:0","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"在 laravel 中使用 laravel mix ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:1:0","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"建立專案 new a project composer create-project laravel/laravel --prefer-dist laravelmix-demo 執行 npm install 來安裝 laravel 預設會用到的 node packages (如：lodash, bootstrap, webpack, babel…) npm install 執行 npm run 可以查看有哪些 scripts 可以使用 (設定在 package.json) npm run dev：npm run development的縮寫，進行一次打包 npm run watch：監聽檔案更動，即時執行打包 npm run watch-poll：在某些系統上，npm run watch 並不總是有效的，此時可以嘗試使用此指令 npm run prod：npm run production的縮寫，進行一次打包並壓縮(minify)程式碼 ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:1:1","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"資料夾結構 此篇文章的 laravel 版本是 laravel 8 laravel 8 預設的 webpack.mix.js 設定如下： mix.js('resources/js/app.js', 'public/js') .postCss('resources/css/app.css', 'public/css', [ // ]); 在這個設定下執行過一次打包後(npm run dev)，資料夾結構如下： 📂 public 📂 js app.js：打包後的js 📂 css app.css：打包後的css 📂 resources 📂 css app.css：預設的來源css 📂 js app.js：預設的來源js，會 require bootstrap.js bootstrap.js：此 bootstrap 非彼 bootstrap，而是指一個用來引入/設定所有需要套件的js(如：axios, lodash…) webpack.mix.js：使用 laravel mix 提供的 api 進行 webpack 的設定 ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:1:2","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"laravel mix api 說明 下為 laravel 8 預設的 webpack.mix.js 設定，這段設定相當直觀，就是 將 resources/js/app.js 打包到 public/js 資料夾中 (public/js/app.js) 將 resources/css/app.css 打包到 public/css 資料夾中 (public/css/app.css) webpack.mix.js mix.js('resources/js/app.js', 'public/js') .postCss('resources/css/app.css', 'public/css'); PostCSS？ PostCss 是一個使用 JavaScript 轉換 CSS 的工具，可以做的事情很多，如： autoprefixer 加入各家瀏覽器的前綴詞 (-webkit-、-moz- 等…)。 postcss-preset-env 將modern css轉為目前主流瀏覽器所能支援的語法 Linters 當有語法錯誤時，console 錯誤訊息 相較於 sass, scss 等預處理器（Preprocessors），PostCSS 同時扮演後處理器（Postprocessors）的角色 預處理器：讓開發者撰寫一些類似 CSS 的語法，再轉為瀏覽器能懂的 CSS 後處理器：寫好的 CSS 經過擴充功能（plugin）的後製處理，將特定功能轉成瀏覽器能懂的指令。 /* laravel 8 預設用 PostCSS 編譯 app.css， 所以當我在 resources/css/app.css 寫入： */ input.test { appearance: slider-horizontal; } /* 經過打包後，public/css/app.css 會呈現： */ input.test { -webkit-appearance: slider-horizontal; -moz-appearance: slider-horizontal; appearance: slider-horizontal; } /* 這是由於 PostCSS 的 autoprefixer 為其加上了各瀏覽器的前綴詞 */ 將多個檔案合併打包至一個檔案 mix.styles([ 'resources/css/card.css', 'resources/css/button.css' ], 'public/css/card-and-btn.css'); mix.scripts([ 'resources/js/disscount.js', 'resources/js/product.js' ], 'public/js/cart.js'); 也可以用 import 的方式進行合併檔案 css 可以用 postcss-import javascript 可以用 es6 module 語法 ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:1:3","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"參考資料 Getting Started with Laravel Mix, Part 2: Setup PostCSS | Summer。桑莫。夏天 ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:2:0","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"練習檔案 https://github.com/hdsbook/laravelmix-demo.git ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:3:0","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"webpack + babel","date":"2020-10-07","objectID":"/20201007-webpack-note/","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"什麼是 Webpack ？ 隨著時代的演進，現代前端的開發不再只是 html、css、js 三大元素。 現代前端多了很多新技術與框架，如 scss、pug、Vue、React、ES6 javascript、CSS3 等… 但是我們的瀏覽器(如：古早味的IE)可能還是只看得懂舊版的 html、css、js， 所以我們需要一個第三方的打包工具，來幫我們編譯這些新技術程式碼， 轉換為瀏覽器看得懂的最原始的三大元素 (html、css、js)， 並且在打包的過程中可以進行壓縮，優化程式碼的效能。 而這些第三方的打包工具中(如：Webpack, gulp.js…)，最廣為人知，被許多框架採用的， 就是 Webpack。 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:1:0","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"什麼是 Babel？ Babel 可以幫我們把高版本 (ECMAScript 6 以上) 的 javascript，降轉成舊版本等效的 js 讓瀏覽器能夠去解讀。 也就是說如果只用 Webpack 打包 javascript，部份瀏覽器還是會因為其中用了 es6 的語法而無法運行。 若在 Webpack 上掛載 Babel 模組，就可以在打包的過程也進行 js 版本的降轉。 一般我們使用 Webpack ，都會掛載 babel 來為我們降轉 js 版本， 使打包出來的檔案可以被大部份瀏覽器解讀 (理論上可以支持到 ie 9)， 在 laravel 中，laravel-mix 所用的 webpack 就預設整合了 babel 模組。 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:2:0","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"Webpack 的部署 Webpack 建立在 node.js 的開發環境下，所以電腦需先裝好 node.js， 而 nvm(Node Version Manager) 是用來 安裝/使用 不同版本的 node.js 的工具， 因此若要在 mac 上安裝 node.js ，可以 先用 homebrew 安裝 nvm，再用 nvm 安裝 node.js，步驟記錄如下： ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:0","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"1. 安裝 Node.js (參考自：Install NVM On Mac With Brew) 若電腦中已有安裝 node，先取消安裝之 brew uninstall --ignore-dependencies node brew uninstall --force node 安裝 nvm brew update brew install nvm 安裝後，它會提示你建立一個資料夾 mkdir ~/.nvm 並在~/.bash_profile 中寫入： export NVM_DIR=~/.nvm source $(brew --prefix nvm)/nvm.sh 執行 source ~/.bash_profile nvm install [版本號，不用輸入得很精確] nvm install 12 查看 node.js 版本 nvm ls 切換 node.js 版本 nvm use 12 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:1","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"2. 安裝 Webpack npm i -g webpack npm i -g webpack-dev-server npm i -g webpack-cli ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:2","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"3. 部署 Webpack 建立資料夾並初始化 mkdir webpack-demo cd webpack-demo npm init -y 安裝 webpack-cli npm install webpack webpack-cli --save-dev 新增 index.js 與 webpack.config.js webpack-demo/src/index.js const arr = ['1', '2', '3']; arr.map(item =\u003e console.log(item)); webpack-demo/webpack.config.js const path = require('path'); module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'index.bundle.js' }, }; 上面的設定就是要把 ./src/index.js 打包到 ./dist/index.bundle.js 設定好便可執行 webpack 指令進行打包，打包後，檔案結構如下圖所示 webpack 到目前為止，因為我們只有用webpack進行打包，還沒有掛載 babel 做js版本的降轉， 所以如果仔細去看打包出來的 index.bundle.js，裡面的內容還是維持 index.js 中 es6 的語法 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:3","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"4. 掛載 Babel 模組 安裝 babel-loader (參考自官方文件 babel-loader)，於 webpack-demo 資料夾執行： npm install -D babel-loader @babel/core @babel/preset-env -D 與 --save-dev 同義，就是要把模組資訊加到 package.json 中 於 webpack.config.js 中加入模組設定，加入後 webpack.config.js 如下 const path = require('path'); module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'index.bundle.js' }, module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } ] } }; 此時再執行 webpack 打包，出來的 index.bundle.js 就會是經過降轉的 js 了 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:4","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"5. webpack 指令說明 webpack 指令其實可以指定 mode (development/production)，和給一個 watch 參數使其能自動打包 development mode 為開發階段所用，為提高打包效率，不進行壓縮； production mode 為上線專案所用，進行壓縮以提高程式執行效能，但打包過程需要較多時間。 當給予 –watch 參數時，webpack 會監聽檔案的 onchange，當檔案發生變動時，自動進行打包。 webpack --mode development 進行一次打包 (不進行壓縮) webpack --mode production 進行一次打包 (進行壓縮，較耗效能) webpack --mode development --watch 持續監聽檔案，若有更動，即時進行打包 (不進行壓縮) ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:5","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"6. npm run script 設定 在 package.json 中，有一個很方便的 scripts 設定，讓我們可以簡化執行 webpack 的指令 打開 package.json，在 scripts 設定中加入： \"scripts\": { \"watch\": \"webpack --mode development --watch\", \"start\": \"webpack --mode development\", \"deploy\": \"webpack --mode production\" }, 這樣當我們想執行 webpack --mode development --watch，就可以直接執行npm run watch； 想執行 webpack --mode development，就執行 npm run start，以此類推… 開發階段，用 npm run watch 部署到正試機，用 npm run deploy ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:6","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"參考資料 Webpack 前端自動化開發超入門 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:4:0","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"練習檔案 https://github.com/hdsbook/webpack-demo ","date":"2020-10-07","objectID":"/20201007-webpack-note/:5:0","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"es6 features","date":"2020-10-06","objectID":"/20201006-es6-note/","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"es6 features 最近透過兩門線上課程學習現代前端的知識，在此紀錄一下對於 es6 語法的觀念及細節 ","date":"2020-10-06","objectID":"/20201006-es6-note/:0:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"let 與 const var 的作用範圍是 scope(作用域) function scope global scope (不是在函式中，就是 global scope) let, const 的作用範圍是 block (用大括號來介定它的範圍) 大括孤，中間有程式碼，稱為 block const 是不能被更改(reassign) 的變數 (可以換家具，不可以搬家) 常用來宣告元素實體。物件、陣列、函式也常以 const 宣告 只有在 object、array 的情況下可以塞東西，但不可以改變型別，所以在嚴謹的情況下會使用 const 來宣告物件或陣列 const 可視為不能 reassign 的 let var 與 function 有 hoisting 的特性，let 與 const 沒有 let 與 const 可以完全取代 var var num = 1; if (true) { // 變數的作用範圍在 global scope var name = \"tony\"; // let 是用大括號來介定它的範圍 // 暫時性的變數用 let 宣告 (local 變數) let num = 2; // const 是不能被更改的變數，且作用範圍是local，常用在宣告 document.getElementById() const selector = \"a\"; // selector = \"b\"; console.log(selector); } console.log(name); console.log(num); // 1 // const 只有在 object 和 array 的情況下可以塞東西，但不可以改變型別 // 所以在嚴謹的情況下會使用 const 來宣告物件或陣列 const a = {}; a.name = \"Mike\"; a.name = \"Judy\"; // a = []; // 不被允許 console.log(a); const b = []; b.push(1); // b = 2; // 不被允許 console.log(b); ","date":"2020-10-06","objectID":"/20201006-es6-note/:1:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"解構賦值 ","date":"2020-10-06","objectID":"/20201006-es6-note/:2:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"陳列解構 考慮一陣列： const arr = [1, 2, 3]; // first = 1, second = 2 const [first, second] = arr; // first = 1, second = 2, third=3, fourth=4(取預設值) const [first, second, third, fourth=4] = arr; // second = 2 const [, second] = arr; // third = 3 const [,, third] = arr; 利用陣列解構達到變數交換 [a, b] = [b, a]; 取得剩餘陣列值 const nums = [1, 2, 3, 4]; const [first, ...others] = nums; // first === 1, nums =\u003e [2, 3, 4] ","date":"2020-10-06","objectID":"/20201006-es6-note/:2:1","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"物件解構 const user = { name: \"Mike\", age: 12, address: \"Taiwan\", }; // 可以重新命名(age =\u003e userAge)，可以指定預設值(sex='male') const { name, age:userAge, address, sex='male' } = user; console.log(name, userAge, address, sex); // 直接將物件放到物件中，物件會在物件中自動進行解構(以變數名稱為其key值) const userData = { user, // 會自動解構成 =\u003e user: {name: \"Mike\", ... } }; console.log(userData); ","date":"2020-10-06","objectID":"/20201006-es6-note/:2:2","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"解構函式參數 function distance(point) { const {x, y} = point; return Math.sqrt(x*x + y*y); } 可以直接在參數解構，並亦可給予預設值 function distance({x, y=0}) { return Math.sqrt(x*x + y*y); } ","date":"2020-10-06","objectID":"/20201006-es6-note/:2:3","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"物件縮寫 (Object shorthand) ","date":"2020-10-06","objectID":"/20201006-es6-note/:3:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"屬性縮寫 let x = y = 0; const point = { x: x, y: y } 可以縮寫成 const point = {x, y} ","date":"2020-10-06","objectID":"/20201006-es6-note/:3:1","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"計算屬性 let key = 'price'; const blog = { }; blog[key] = 100; 可用[]包住變數代入key值，[]中可放入計算式 let key = 'price'; const blog = { [key]: 100, ['discount_' + key]: 80 } ","date":"2020-10-06","objectID":"/20201006-es6-note/:3:2","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"函式縮寫 const options = { mounted: function () { }, } 消去冒號與function關鍵字，可縮寫成： const options = { mounted() { }, } ","date":"2020-10-06","objectID":"/20201006-es6-note/:3:3","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"箭頭函式運算式 const Add = function (a, b) { return a + b; } // 省略 function 關鍵字，加上鍵頭，變成： const Add = (a, b) =\u003e { return a + b; } // 當回傳只有一行時，可進一步簡化成： const Add = (a, b) =\u003e a + b; // 當函數參數只有一個的時候，可以省略參數的小括孤 const Double = a =\u003e a * 2; 箭頭函式中沒有this，this會往上一層找 若要取得dom元素實體本身，則要透過 e.target 取得 document.getElementById(\"aLink1\").addEventListener(\"click\", function () { console.log(this); // 指向 #aLink1 }); document.getElementById(\"aLink2\").addEventListener(\"click\", (e) =\u003e { // 箭頭函式中沒有this，this會往上一層找 console.log(this); // 指向 window // 若要取得dom元素實體本身，則要透過 e.target 取得 console.log(e.target); // 指向 #aLink2 }); 箭頭函數的參數可以指定預設值 const ArrayToStr = (arr = [1, 1, 1, 1]) =\u003e { return arr.map((item) =\u003e item + \"\"); } ","date":"2020-10-06","objectID":"/20201006-es6-note/:4:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"函數的 this 指向誰，取決於如何執行函式 this的定義？ this是函式的context(情境)，就是指函式執行的情境、函式被呼叫的方法 function jump() { console.log(this); } // 1. 直接執行 (this 為 gloabal 或 window) jump(); // this 指向 window // 2. 作為物件的成員函式執行 (this 為 該物件) var a = {}; a.jump = jump; a.jump(); // this 指向 a // 3. 綁定 dom 事件 (this 為 發出事件的DOM) btn.addEventListener('click', jump); // this 指向 #btn dom 物件 // 當用箭頭函式宣告，則不管怎麼執行，this都是上層的this (箭頭函數沒有自己的 this) const jump = () =\u003e { console.log(this) } ","date":"2020-10-06","objectID":"/20201006-es6-note/:5:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"字串模版 // 透過字串模版，可以更方面的進行字串與變數的串接、換行 const add = (name, age) =\u003e { return ` Hi 我叫${name}， 我今年${age}歲 `; }; console.log(add(\"Mike\", 12)); ","date":"2020-10-06","objectID":"/20201006-es6-note/:6:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"ES module ./js/Tools.js const Add = (a, b) =\u003e { return a + b; }; // 可以 export 很多東西出去，但是default只能有一個 export default Add; // 要用 export 丟出去的只能用 const 變數丟出去 (named export) export const Name = \"mike\"; export const age = 12; export const Minus = (a, b) =\u003e { return a - b; } index.html \u003c!-- 用 type=\"module\" 告訴瀏覽器這邊是屬於 es6 module 的用法，讓它認得 import 指令 --\u003e \u003cscript type=\"module\"\u003e // 除了 default 的東西，其它要用解構的方式 import 進來 import Add, { Name as userName, age, Minus } from \"./js/Tools.js\"; console.log(Add(1, 2)); console.log(userName); console.log(age); console.log(Minus(5, 3)); \u003c/script\u003e ","date":"2020-10-06","objectID":"/20201006-es6-note/:7:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"Class class Dog extends Animal { constructor() { this.age = 0; } bark() { console.log('woof'); } } const dog = new Dog(); class Dog extends Animal { this.age = 0; bark() =\u003e console.log('woof'); } const dog = new Dog(); 參考資料： 2020 Vue3 專業職人 | 入門篇 (預購中) - HiSKIO 跨領域學程式 | 專業程式線上課程平台 | 嗨 程式技能 React 16 完全精通 - 從原理到大量實戰應用 - HiSKIO 跨領域學程式 | 專業程式線上課程平台 | 嗨 程式技能 ","date":"2020-10-06","objectID":"/20201006-es6-note/:8:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":null,"content":"ace-code-editor, showdown, github-markdown-css","date":"2020-07-15","objectID":"/20200715-markdown-editor-by-ace-and-showdown/","tags":["markdown","javascript"],"title":"Markdown editor with vscode keybinding","uri":"/20200715-markdown-editor-by-ace-and-showdown/"},{"categories":null,"content":"ace-code-editor, showdown, github-markdown-css 此篇文章分享如何簡單建立一個好用的 markdown editor 將會用到兩個 js 套件：ace-code-editor 和 showdown markdown 呈現的 css 則套用 github-markdown-css 那就開始吧 ","date":"2020-07-15","objectID":"/20200715-markdown-editor-by-ace-and-showdown/:0:0","tags":["markdown","javascript"],"title":"Markdown editor with vscode keybinding","uri":"/20200715-markdown-editor-by-ace-and-showdown/"},{"categories":null,"content":"1. git init \u0026 npm init mkdir showdown-practice cd showdown-practice git init npm init ","date":"2020-07-15","objectID":"/20200715-markdown-editor-by-ace-and-showdown/:1:0","tags":["markdown","javascript"],"title":"Markdown editor with vscode keybinding","uri":"/20200715-markdown-editor-by-ace-and-showdown/"},{"categories":null,"content":"2. npm install npm install jquery npm install bootstrap npm install showdown npm install github-markdown-css npm install ace-builds ","date":"2020-07-15","objectID":"/20200715-markdown-editor-by-ace-and-showdown/:2:0","tags":["markdown","javascript"],"title":"Markdown editor with vscode keybinding","uri":"/20200715-markdown-editor-by-ace-and-showdown/"},{"categories":null,"content":"3. index.html \u003clink rel=\"stylesheet\" href=\"node_modules/github-markdown-css/github-markdown.css\"\u003e \u003clink rel=\"stylesheet\" href=\"node_modules/bootstrap/dist/css/bootstrap.min.css\"\u003e \u003cstyle\u003e body { height: 100vh; } \u003c/style\u003e \u003cdiv class=\"d-flex justify-content-around align-items-center h-100 p-5\"\u003e \u003cdiv class=\"flex-fill h-100 m-3 mb-5\"\u003e \u003ch3\u003eInput markdown\u003c/h3\u003e \u003cdiv id=\"markdownArea\" class=\"border rounded w-100 h-100\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"flex-fill h-100 m-3 mb-5\"\u003e \u003ch3\u003eOutput Html\u003c/h3\u003e \u003cdiv id=\"outputArea\" class=\"markdown-body border rounded w-100 h-100 p-3 overflow-auto\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript src=\"node_modules/showdown/dist/showdown.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"node_modules/jquery/dist/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"node_modules/ace-builds/src-min/ace.js\"\u003e\u003c/script\u003e \u003cscript\u003e $(function() { var editor = initEditor(\"markdownArea\", \"outputArea\"); }); function initEditor(inputId, outputId) { let editor = ace.edit(inputId); // editor.setReadOnly(true); // 是否唯讀 editor.setTheme(\"ace/theme/dawn\"); // 主題樣式 editor.setShowPrintMargin(false); // 不要顯示右方 margin editor.setKeyboardHandler(\"ace/keyboard/vscode\"); // 快捷鍵類型 (keybinding) editor.session.setMode(\"ace/mode/markdown\"); // 內容語言類型 editor.session.on('change', function(delta) { // delta.start, delta.end, delta.lines, delta.action var markdownText = editor.getValue(); var html = markdownToHtml(markdownText); $(\"#\" + outputId).html(html); }); return editor; } function markdownToHtml(text) { var converter = new showdown.Converter(); return converter.makeHtml(text); } \u003c/script\u003e 以上為最簡化的程式，詳細可再到我的 github 上查看 ","date":"2020-07-15","objectID":"/20200715-markdown-editor-by-ace-and-showdown/:3:0","tags":["markdown","javascript"],"title":"Markdown editor with vscode keybinding","uri":"/20200715-markdown-editor-by-ace-and-showdown/"},{"categories":["loveItDoc"],"content":"好用的提示框 shortcode","date":"2020-07-01","objectID":"/0-loveit-admonition-note/","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":" admonition(警告/訓詞) shortcode 提供 12 種樣式讓你可以在文章中放入各種提示 Markdown 或 HTML 也都可以寫入 admonition ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:0:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Note Note Some note tips… {{\u003c admonition note \"Note\" \u003e}} Some note tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:1:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Abstract Abstract Some abstract tips… {{\u003c admonition \"Abstract\" \u003e}} Some abstract tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:2:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Info Info Some info tips… {{\u003c admonition info \"Info\" \u003e}} Some info tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:3:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Tip Tip Some tip tips… {{\u003c admonition tip \"Tip\" \u003e}} Some tip tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:4:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Success Success Some success tips… {{\u003c admonition success \"Success\" \u003e}} Some success tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:5:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Question Question Some question tips… {{\u003c admonition question \"Question\" \u003e}} Some question tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:6:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Warning Warning Some warning tips… {{\u003c admonition warning \"Warning\" \u003e}} Some warning tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:7:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Failure Failure Some failure tips… {{\u003c admonition failure \"Failure\" \u003e}} Some failure tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:8:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Danger Danger Some danger tips… {{\u003c admonition danger \"Danger\" \u003e}} Some danger tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:9:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Bug Bug Some bug tips… {{\u003c admonition bug \"Bug\" \u003e}} Some bug tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:10:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Example Example Some example tips… {{\u003c admonition * \"Example\" \u003e}} Some example tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:11:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Quote Quote Some quote tips… {{\u003c admonition quote \"Quote\" \u003e}} Some quote tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:12:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"admonition 有三個參數可以設定，你可以選擇以下兩種寫法 {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} {{\u003c /admonition \u003e}} OR {{\u003c admonition tip \"This is a tip\" false \u003e}} {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:13:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":null,"content":"簡歷 See the Pen 動畫互動網頁特效入門 Project 1：個人履歷 by hdsbook (@hdsbook) on CodePen. ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"網站使用的 Hugo 主題：LoveIt  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \" Hugo Theme LoveIt ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"About Me","uri":"/about/"}]