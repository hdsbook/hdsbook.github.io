[{"categories":[],"content":"魔鬼藏在細節中","date":"2020-12-03","objectID":"/20201203-javascript-traps/","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"最近面試了幾間公司，才發現自己在 javascript 一些細節的基礎知識實在不夠扎實，實在汗顏 所以此篇文章應該會陸續加入自己看過或遇到過的 javascript 坑，並大至簡單的說明其原因 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:0:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"0.1 + 0.2 != 0.3 console.log(0.1 + 0.2); // 0.30000000000000004 javascript 進行計算前需要先把浮點數轉化為二進位數 但當 0.1 轉為二進制時，為 0.0001 1001 1001… 的無限循環小數 而 javascript 浮點數計算最多支持到第52位小數 捨去52位後的小數然後計算，計算結果再轉為10進位小數 就得到了最後這個有誤差的結果了 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:1:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"[3,5,7,11].sort() [3,5,7,11].sort(); // [11, 3, 5, 7] 因為 javascript 默認使用字典序(alphanumeric)來排序。 欲正確排序的話，應該改寫為 [3, 5, 7, 11].sort( (a,b) =\u003e a-b ) ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:2:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt parseInt(3, 10); // 3 parseInt(3, 0); // 3 parseInt(3, 8); // 3 parseInt(3, 2); // NAN parseInt(3, 37); // NAN ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:3:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt：函式說明 parseInt 的第一個參數為數字或字串，第二個參數為 radix 基數 其運作方式是先將第一個參數轉為字串 然後以第二個參數為基數解析第一個參數 回傳第一個參數的十進位的值，如： parseInt(101, 2) = parseInt(“101”, 2) = 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 4 + 0 + 1 = 5 parseInt(‘2F’, 16) = 2 * 16^1 + 15 * 16^0 = 32 + 15 = 47 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:3:1","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt：問題1: 傳入0為基數 如果 第二個參數(radix) 給的是 0，則其效果同傳入預設值 10 所以 parseInt(3, 0) 會等於 parseInt(3, 10) ，結果自然就是 3 了 然而 radix 的預設值可能會因為特殊的執行情境而有不是10的情況 所以使用這個函式時建議還是明確加上第二個參數 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:3:2","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt：問題2: 不合法的表示法會回傳 NAN parseInt(3, 2) 是 NAN 的原因是，在 2 進制表示法中，應該只會出現 0 和 1 才對 如：1011010，意即，2進制的表示法中，不可能出現大於等於2的數字 所以 parseInt(3, 2) 因為出現了3，所以結果就是 NAN 了 同理 parseInt(5, 5) 也會是 NAN， 因為 5進制的表示法應該是如：402314，會出現的最大數字是4 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:3:3","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt：問題3: 基數的上下限 第二個參數radix是有範圍限制的，就是不能大於36，也不能小於 2 當傳入基數大於36，或小於2時(0除外)，回傳NaN ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:3:4","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"parseInt 延伸問題 [1, 2, 3].map(parseInt); // [1, NaN, NaN] 先了解一下 array.map 的參數： array.map(callback(currentValue, index, array), this) currentValue: 各陣列 item 值，以上例來說，依序會是 1, 2, 3 index: 各陣列 item 索引，以上例來說，依序會是 0, 1, 2 故該程式碼的執行就會是如下： parseInt(1, 0); // 同 parseInt(1, 10) =\u003e 1 parseInt(2, 1); // radix \u003c 2 =\u003e NaN parseInt(3, 2); // 2 進制的表示法不會有大於等於2的數字 =\u003e NaN ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:4:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"Math.min() \u003e Math.max() Math.min() \u003c Math.max() // false Math.min() \u003e 0 // true Math.max() \u003e 0 // false Math.max() 回傳 -Infinity Math.min() 回傳 Infinity ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:5:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"參考資料： https://juejin.cn/post/6847902225872879630 ","date":"2020-12-03","objectID":"/20201203-javascript-traps/:6:0","tags":[],"title":"Javascript 的陷阱","uri":"/20201203-javascript-traps/"},{"categories":[],"content":"解決 api routes authentication 問題","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"之前一直有遇到一個問題是經由 routes/api.php 的路由怎麼樣也無法取得 Auth::user() 的資料 也無法做出正確的使用者驗證，此篇針對此問題紀錄解決方案與問題原因 ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:0:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"了解 Middleware groups middleware 中介層，為 HTTP request 進入 Controller 之前的中間過濾/處理器 middleware groups 也就是一組中介層，套用該 middleware groups 的路由需依序進行各中介層的檢查 Laravel 的 middleware groups 預設有兩組，web 與 api \u003c?php // app/Http/Kernel.php protected $middlewareGroups = [ // web middleware group 'web' =\u003e [ // ... \\Illuminate\\Session\\Middleware\\StartSession::class, // ... \\App\\Http\\Middleware\\VerifyCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], // api middleware group 'api' =\u003e [ 'throttle:api', // 對照下面的 $routeMiddleware 可知為執行 ThrottleRequests 並以 api 為參數 \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], ]; protected $routeMiddleware = [ // ... 'throttle' =\u003e \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, ]; 套用 web 的 route 會依序執行：StartSession, VerifyCsrfToken, SubstituteBindings 等 middleware 套用 api 的 route 會依序執行:ThrottleRequests(以 ‘api’ 為參數) 和 SubstituteBindings 兩個 middleware 並且由 RouteServiceProvider 可知： routes/api.php 預設使用 api middleware group routes/web.php 預設使用 web middleware group \u003c?php // app/Providers/RouteServiceProvider.php /** * Define your route model bindings, pattern filters, etc. * * @return void */ public function boot() { $this-\u003econfigureRateLimiting(); $this-\u003eroutes(function () { Route::prefix('api') -\u003emiddleware('api') -\u003enamespace($this-\u003enamespace) -\u003egroup(base_path('routes/api.php')); Route::middleware('web') -\u003enamespace($this-\u003enamespace) -\u003egroup(base_path('routes/web.php')); }); } ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:1:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"了解 Authenticate guards Laravel 預設的 authenticate guards 也有兩組，用來決定以什麼樣的方式進行使用者驗證 取了同樣的名稱，一個是 web，一個是 api 為了必免與 middleware group 混淆，以下稱為 web guard、api guard web guard 的 driver 是 session， api guard 的 driver 是 token \u003c?php // config/auth.php 'guards' =\u003e [ // web guard 'web' =\u003e [ 'driver' =\u003e 'session', 'provider' =\u003e 'users', ], // api guard 'api' =\u003e [ 'driver' =\u003e 'token', 'provider' =\u003e 'users', 'hash' =\u003e false, ], ], ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:2:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"分析為何無法在 api routes 驗證使用者 在 routes/api.php 預設的內容如下 \u003c?php Route::middleware('auth:api')-\u003eget('/user', function (Request $request) { return $request-\u003euser(); }); 嘗試 fetch 這個 api，或是改成 Route::middleware('auth:web')，卻都返回 {message: 'Unauthenticated'} 有兩層原因，一個是 session 問題，一個是 token 設定問題 如果要通過使用者認證，一定要通過任一個 authenticate guard web guard 是透過 session 認證，api guard 是透過 token 驗證 session 問題 =\u003e 不能使用 web guard 無法使用web guard，意即不能採取Route::middleware('auth:web')的方式 原因是 routes/api.php 預設使用 api middleware group，其中的中介層中沒有經過 StartSession 所以就算選擇使用 web guard，也會因為沒有 session 可以取得而認證失敗 事實上 laravel 官方也不建議讓 api 路由再藉由 session 的方式做使用者認證，應該採取較嚴謹的 token 做法 所以在 routes/api.php 的預設程式碼才會看到預設傳給 auth middleware 的認證護衛是 api guard token 設定問題 =\u003e 需額外設定 但如果使用 api guard，就必須做好 token 相對應的設定 而 token 驗證的方式太多元，laravel 並沒有預先配置好任一種方式 而很多開發者，可能都把 api routes 寫到 web.php，走 web middleware、web guard，一樣以 session 做認證 所以官方就將這部份作為一個進階彈性的設定選項，沒有預設載入這部分的配置 簡言之，官方預設： routes/web.php 走 web middleware group，有經過 StartSession，可以使用 web guard 以 session 驗證 routes/api.php 走 api middleware group，沒經過 StartSession，只能使用 api guard 以 token 驗證 但是 token 驗證的方式請自行搞定 ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:3:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"配置 token authentication ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"核心邏輯 其實 token 驗證的核心邏輯很簡單，就是給 users 資料表加上一個 api_token 的欄位， 並且在 request 的時候，也要傳入該 token 的值 比方說，現在已登入的使用者，其紀錄在資料表中對應的 api_token 是 a9lkjw7eoruosdvlaskjerioudoj... 那發出的 api request 就要傳入一樣的 token axios.get('api/...', { params: { api_token: 'a9lkjw7eoruosdvlaskjerioudoj...' } }) 至於為什麼是要加上 api_token 這個欄位，是參考自官方文件的說明 (https://laravel.com/docs/5.8/api-authentication#introduction) ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:1","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"步驟 0： 確認預設設定 確認 api guard 使用 token driver \u003c?php // config/auth.php 'guards' =\u003e [ 'web' =\u003e [ 'driver' =\u003e 'session', 'provider' =\u003e 'users', ], 'api' =\u003e [ 'driver' =\u003e 'token', 'provider' =\u003e 'users', 'hash' =\u003e false, ], ], ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:2","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"步驟 1： 新增 api_token 欄位 php artisan make:migration add_api_token_to_users \u003c?php use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; class AddApiTokenToUsers extends Migration { public function up() { Schema::table('users', function (Blueprint $table) { $table-\u003estring('api_token', 60) -\u003eunique() -\u003enullable() -\u003edefault(null) -\u003eafter('password'); }); } public function down() { Schema::table('users', function (Blueprint $table) { $table-\u003edropColumn('api_token'); }); } } php artisan migrate ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:3","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"步驟 2：於登入時產生 api token 註冊 login listener php artisan make:listener SuccessLogin \u003c?php // app/Listeners/SuccessLogin.php namespace App\\Listeners; use Illuminate\\Contracts\\Queue\\ShouldQueue; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Support\\Facades\\Auth; use Illuminate\\Support\\Str; class SuccessLogin { public function handle($event) { $user = Auth::user(); $user-\u003eapi_token = Str::random(60); $user-\u003esave(); } } 於 EventServiceProvider 加入 listener \u003c?php // app/Providers/EventServiceProvider.php namespace App\\Providers; // ... use App\\Listeners\\SuccessLogin; use Illuminate\\Auth\\Events\\Login; class EventServiceProvider extends ServiceProvider { protected $listen = [ // ... Login::class =\u003e [ SuccessLogin::class, ] ]; } ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:4","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"步驟 3：使 axios 預設帶入 token 將 api token 與 csrf token 放到 meta tag 上 \u003cmeta name=\"csrf-token\" content=\"{{ csrf_token() }}\"\u003e @auth \u003cmeta name=\"api-token\" content=\"{{ Auth::user()-\u003eapi_token }}\"\u003e @endauth 將 api token 與 csrf token 設定到 axios 的 header // bootstrap.js window.axios = require('axios'); window.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest'; const csrfMetaTag = document.querySelector('meta[name=\"csrf-token\"]'); csrfMetaTag ? window.axios.defaults.headers.common['X-CSRF-TOKEN'] = csrfMetaTag.getAttribute('content') : console.log('csrf token not found'); const apiMetaTag = document.querySelector('meta[name=\"api-token\"]'); apiMetaTag ? window.axios.defaults.headers.common['Authorization'] = \"Bearer \" + apiMetaTag.getAttribute('content') : console.log('api token not found'); ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:5","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"步驟 4：完成 確認 routes/api.php 預設內容 \u003c?php // routes/api.php Route::middleware('auth:api')-\u003eget('/user', function (Request $request) { return $request-\u003euser(); }); 進行測試： // app.js axios.get('http://127.0.0.1:8000/api/user').then(res =\u003e { console.log(res); }); 重新登入應該就可以看到 log 出 axios 回傳的 user data 了解 ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:4:6","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"結語 上述的步驟 2 和 3 的方式是參考自 這篇文章 的做法 雖然這樣的做法還是將 api token 放到 meta tag 上了，但每次登入都會進行 token 的代換 已經可以算是最簡單的方式 如果要再更嚴謹的話，應該是要建立一個 controller 更新 token 再將 token 傳回給前端框架使用，或是存到 window.localStorage \u003c?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Str; use Illuminate\\Http\\Request; class ApiTokenController extends Controller { /** * Update the authenticated user's API token. * * @param \\Illuminate\\Http\\Request $request * @return array */ public function update(Request $request) { $token = Str::random(60); $request-\u003euser()-\u003eforceFill([ 'api_token' =\u003e hash('sha256', $token), // 這邊用 hash 的話，config/auth.php 的 hash 設定就要改成 true ])-\u003esave(); return ['token' =\u003e $token]; } } 但就如前面所說，token驗證的方式實在有很多種方式， 只要了解其核心邏輯，開發者其實可以自行決定要怎麼做， 希望這篇文章有幫助到和我遇到一樣問題的人 ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:5:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"參考資料 https://learnku.com/articles/11006/detailed-explanation-of-laravels-own-api-guard-drive-token https://learnku.com/docs/laravel/5.8/api-authentication/3952 https://laravel.com/docs/5.8/api-authentication#introduction https://caloskao.org/laravel-api-token-usage/ ","date":"2020-11-14","objectID":"/20201114-laravel-api-authentication/:6:0","tags":["laravel"],"title":"Laravel api authentication","uri":"/20201114-laravel-api-authentication/"},{"categories":[],"content":"慣例優於設定 Convention over configuration","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"命名常常是令人最頭痛的環節，一個專案中沒有統一的命名規則，可能會造成開發上的疑惑， 本文參考官方文件，簡單整理了在 Laravel 中幾個命名慣例的規則 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:0:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"命名的方式 camelCase 小駝鋒式命名 snake_case 蛇行命名 PascalCase (pascal 是一門程式語言) 或稱 大駝鋒式命名 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:1:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"約定優於配置(Convention over configuration) 定義 約定優於配置(CoC)，或稱「慣例優於設定」 是一種軟體設計範式，旨在減少軟體開發人員需做決定的數量，獲得簡單的好處，而又不失靈活性 開發者只需設定偏離約定的項目 例如，當 Ｍodel 名為 Sale 時，則對應的資料表默認(約定)為 sales 也就是 Model 的 $table 屬性預設為 sales 只有在偏離這一約定時，例如將資料表命名為 “products_sold”，才需覆寫 Model 的 $table 屬性 為 “products_sold” \u003c?php // Sale Model class Sale extends Model { // 預設值為 sales，覆寫為 products_sold protected $table=\"products_sold\" } 而這樣只需對偏離約定的項目進行設定的概念就是所謂的 約定優於配置 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:2:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"Laravel Mdel / table / Seeder 命名慣例 下表第一列是命名對象，第二列紅字列代表命名規則，再往下則是範例 Model table Seeder、Factory PascalCase、單數 snake_case、複數 PascalCase、單數、'Seeder/Factory'為結尾 Post posts PostSeeder / PostFactory Mybook my_books MybookSeeder / MybookFactory Laravel 底層取得默認 $table 值的邏輯可在 Illuminate\\Database\\Eloquent\\Model 的 getTable() 找到 若沒有設定 $table 屬性，它會利用 Illuminate\\Support\\Pluralizer 來取得複數的名詞 這個 Pluralizer 可能比我們預想的都要來的強大，包含以 y 結尾的單字、常見的不可數名詞都能順利轉換 如：Person =\u003e people, Category =\u003e categories, Series =\u003e series, Information =\u003e information… 不管如何，為保守起見，還是可以設定一下 $table 屬性 \u003c?php // Category Model class Category extends Model { // 雖然預設應該就會是 categories，但還是可以習慣設定一下 protected $table=\"categories\" } ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:3:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"Pivot table 的命名 設兩資料表 products 與 features 是透過一個 pivot (中介資料表) 來進行多對多的關聯 則該 pivot 的默認名稱為 feature_product，命名的規則是：依字母排序的單數名詞、snake_case 若希望 pivot 命名為 product_feature_maps，則需在兩個對應的 Model 中設定如下 (加入第二個參數，pivot name) \u003c?php // in Product model public function features() { return $this-\u003ebelongsToMany('App\\Feature', 'product_feature_maps'); } // in Feature model public function products() { return $this-\u003ebelongsToMany('App\\Product', 'product_feature_maps'); } 個人覺得 product_feature_maps 這樣的命名可以讓語意更加明顯 不過官方預設命名為 feature_product 也不是沒有道理 因為當大部份資料表都依慣例被取名為複數的時候，單數命名的資料表應該就是 pivot table 了 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:4:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"Primary/Foreign Key 命名方式 範例 Primary key 一律命名為 id id Foreign key 來源資料表單數名詞 + _id post_id ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:5:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"\u0008結論： 保守為避免出錯可以都設定一下 Model 的 $table 屬性、belongsToMany 的第二參數 當然命名規則最好能盡量符合官方文件的慣例，至少要統一一個規範 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:6:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":[],"content":"\u0008參考資料： 維基百科-約定優於配置(CoC) Laravel 项目开发规范 Laravel 的十八個最佳實踐 為你自己學 Laravel - Day 12 Model 與資料表 Laravel 官方文件 - eloquent-model-conventions stackoverflow-Pivot table 的命名 ","date":"2020-11-02","objectID":"/20201102-laravel-model-naming-convention/:7:0","tags":["laravel"],"title":"Laravel Model 命名慣例","uri":"/20201102-laravel-model-naming-convention/"},{"categories":["laravelPlugins"],"content":"New authentication scaffolding for laravel 8","date":"2020-10-28","objectID":"/20201028-jetstream/","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"5 commands save you 5 days in 5 minutes Laravel Jetstream 是隨著 Laravel 8.x 一同釋出的新套件 同樣由 Laravel 之父 Taylor Otwell 所開發 它提供了登入、註冊、信箱驗證、雙重驗證、Session管理等功能 可以快速為新專案提供一個好的開始 本篇簡述安裝 Jetstream 的過程 ","date":"2020-10-28","objectID":"/20201028-jetstream/:0:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"建立專案 laravel new jetstream-demo laravel 8.x 支援在建立專案時就選擇載入 jetstream，指令如下 laravel new project-name --jet 若沒有在建立專案時就選擇載入 jetstream，循下文用 composer 再 require 進來即可 ","date":"2020-10-28","objectID":"/20201028-jetstream/:1:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"安裝 Jetstream Jetstream 提供 livewire 與 inertia 兩種 frontend stacks (我不知道怎麼翻，就翻\"特殊前端框架\"吧) 安裝 Jetstream 時必須 2 擇 1 ，這裡選擇安裝 livewire 而不管選哪一個，開發時都可以選擇是否使用，或是局部使用 我目前只知道 livewire 好像是 for 對前端框架不那麼熟悉的後端開發者所做的工具 而 inertia 像是可以在 laravel 這個框架上更舒適的使用 Vue.js 詳細教學可以查看官方文件(livewire / inertia) 安裝 Jetstream 的指令如下： composer require laravel/jetstream php artisan jetstream:install livewire 因為 jetstream 它包含了上述框架與 tailwindcss(比 Bootstrap 更有彈性的css架構)，所以安裝好它會提示你要執行以下指令 來將上述框架的 js, css 一起打包到 public/css/app.css 與 public/css/app.js npm install \u0026\u0026 npm run dev ","date":"2020-10-28","objectID":"/20201028-jetstream/:2:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"設定資料庫 在本機端建一個名為 jetstream 的資料庫，並設定 .env DB_CONNECTION=mysql DB_HOST=127.0.0.1 DB_PORT=3306 DB_DATABASE=jetstream DB_USERNAME=root DB_PASSWORD= ","date":"2020-10-28","objectID":"/20201028-jetstream/:3:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"執行 migration php artisan migrate 到目前為止就算部署完成了，相當簡單，可以執行 php artisan serve 就會看到首頁右上角多了 Login 與 Register 的按扭 並且註冊、登入等功能也真的可以正常運作 真的是 5 commands save you 5 days in 5 minutes (而且大部份時間都在等安裝而已) XD ","date":"2020-10-28","objectID":"/20201028-jetstream/:4:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"(optional)設定 public disk link 如果有用到 jetstream 上傳圖片的功能，可能會遇到上傳的圖片破圖的問題，以下為相關說明： config/filesystems.php (檔案系統設定) 紀錄所有磁碟（disk）的設定 每個磁碟設定對應一組儲存驅動與儲存位置(預設有 local, public, s3 三個磁碟設定) 其中 public disk 理論上是要放「能被公開存取的檔案」 但 public disk 預設將檔案存到 storage/app/public，這個位置是無法被公開存取的 (整個網站公開對外的資料夾為 public) 故需執行以下指令，在 public 產生一個 storage 的捷徑，如此 jetstream 上傳的照片就能夠被存取到了 php artisan storage:link 總之就是執行上行指令就對了，對於這個指令的詳細說明可以再參考 Laravel 之有關 storage:link 路徑設置 或 官方說明 ","date":"2020-10-28","objectID":"/20201028-jetstream/:5:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":["laravelPlugins"],"content":"參考資料 Jetstream 官方文件 Laravel 8 官方文件 Laravel Installer 4.0 更新小記 什麼是 Inertia.js 什麼是 Laravel Jetstream 用 Livewire 在 Laravel 應用裡實現無痛的前後端溝通 ","date":"2020-10-28","objectID":"/20201028-jetstream/:6:0","tags":["laravel"],"title":"Laravel Jetstream","uri":"/20201028-jetstream/"},{"categories":[],"content":"Vue component name-casing","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"命名的方式 my-first-component kebab-case (串燒) myFirstComponent camelCase (駝鋒) MyFirstComponent PascalCase (pascal 是一門程式語言) ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:1:0","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"宣告組件的命名沒有限制 可以使用三種命名的任一種 Vue.component('my-first-component', { /* ... */ }) // or Vue.component('myFirstComponent', { /* ... */ }) // or Vue.component('MyFirstComponent', { /* ... */ }) ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:2:0","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"模版的命名 ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:3:0","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"用 HTML 作為 View 的模版 只能用 kebab-case 不能 self closing (一定要加上 closing tag \u003c/my-first-component\u003e) \u003cmy-first-component\u003e\u003c/my-first-component\u003e ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:3:1","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"用 template 作為模版 不管宣告時的命名方式，皆可以用 kebab-case 也可以用 camelCase 或 PascalCase，但須與宣告的命名方式相同 (如：都是camelCase) 可以 self closing Vue.component('my-first-component', { /* ... */ }) // or Vue.component('myFirstComponent', { /* ... */ }) // or Vue.component('MyFirstComponent', { /* ... */ }) new Vue({ el: '#app', template: ` \u003cdiv\u003e \u003cmy-first-component/\u003e \u003c/div\u003e `, }) Vue.component('myFirstComponent', { /* ... */ }) new Vue({ el: '#app', template: ` \u003cdiv\u003e \u003cmyFirstComponent/\u003e \u003c/div\u003e `, }) Vue.component('MyFirstComponent', { /* ... */ }) new Vue({ el: '#app', template: ` \u003cdiv\u003e \u003cMyFirstComponent/\u003e \u003c/div\u003e `, }) ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:3:2","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"結論 均使用 kebab-case 準沒錯 template模版可以 self closing，HTML模版不行 宣告組件的命名沒有限制 HTML模版必用 kebab-case，template 模版可以使用同宣告組件的命名方式 ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:4:0","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":[],"content":"參考資料 Vue 官方網站 精通 VueJS 前端開發完全指南 ","date":"2020-10-13","objectID":"/20201013-vue-component-naming-rule/:5:0","tags":["vue"],"title":"Vue 組件命名學","uri":"/20201013-vue-component-naming-rule/"},{"categories":["tdd"],"content":"走進測試的大門","date":"2020-10-09","objectID":"/20201009-phpunit-note/","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":" PHPUnit 是 PHP編程語言的單元測試框架。 本文從最簡單的範例，說明 PHPUnit 的使用方法 我的電腦環境 OS: macOS 10.15.7 php: 7.3.22 composer: 1.9.2 ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:0:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"1. 建立測試專案 \u0008建立專案資料夾並安裝最新版的 phpunit take php-tdd-demo composer require phpunit/phpunit 這裡我們並不是全域安裝 phpunit，而是在這個專案下可以透過 ./vendor/bin/phpunit 來執行 phpunit 例如執行以下指令查看 phpunit 版本 ./vendor/bin/phpunit --version 建立 src, tests 資料夾 mkdir src tests 此時我們的資料夾結構就如下： 📂 src 我們的來源php程式碼(要被測試的程式)放在這裡 📂 tests 測試程式將被放到這裡來 📂 vendor composer.json composer.lock 在 composer.json 加上以下設定： \"autoload\": { \"psr-4\": { \"Src\\\\\": \"src/\" } }, \"autoload-dev\": { \"psr-4\": { \"Tests\\\\\": \"tests/\" } } ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:1:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"2. 建立我的第一支測試程式 在 tests/ 資料夾新增一個檔案 CalculatorTest.php touch tests/CalculatorTest.php Tip 所有可被執行的測試程式檔案必須取名為 XxxTest.php ！(以Test為結尾，大駝峰式命名) 在 tests/CalculatorTest.php 寫入： \u003c?php use PHPUnit\\Framework\\TestCase; use Src\\Calculator; class CalculatorTest extends TestCase { public function testAdd() { /** @Arange */ $calculator = new Calculator(); $expected = 2; /** @Act */ $actual = $calculator-\u003eadd(1, 1); /** @Assert */ $this-\u003eassertEquals($expected, $actual); } } Tip 所有測試程式需要 extends TestCase 測試函式名稱取為 testXxxx ！(以test為開頭，小駝峰式命名) 在 testAdd 函式中，以3A原則撰寫測試： Arange：準備好要被測試的資料 =\u003e $calculator 計算器物件、預期值 2 Act：調用受測物件的方法 =\u003e 計算器物件傳入兩個1，回傳相加的結果 Assert：驗證是否符合預期 =\u003e 驗證回傳之結果是否符合預期值 2 ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:2:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"3. 執行測試 輸入以下指令會執行 tests/ 資料夾底下符合測試命名規則的所有測試 ./vendor/bin/phpunit tests 可以加入 --testdox 來顯示測試名稱、 --colors 使顯示的結果有顯色 ./vendor/bin/phpunit tests --testdox --colors 結果： 紅燈！出現了 Class 'Tests\\Calculator' not found 的錯誤，因為我們還沒開始寫 Calculator 物件 ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:3:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"4. 開始實作 Calculator 與 add 方法 建立 src/Calculator.php 並寫入： \u003c?php namespace Src; class Calculator { public function add($a, $b) { return $a + $b; } } ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:4:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"5. 再次執行測試程式 執行 ./vendor/bin/phpunit tests --testdox --colors 結果： 綠燈！完成！ ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:5:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["tdd"],"content":"參考資料 TDD 範例三：用 PHPUnit 改寫範例二 PHPUnit 官方網站 程式碼： https://github.com/hdsbook/php-tdd-demo ","date":"2020-10-09","objectID":"/20201009-phpunit-note/:6:0","tags":["phpunit","php"],"title":"PHPUnit 入門","uri":"/20201009-phpunit-note/"},{"categories":["modernWeb"],"content":"Laravel Mix 提供了一個優雅的 API 來為你的專案設定 Webpack","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":" Laravel Mix 提供了一個優雅的 API 來為你的專案設定 Webpack 許多人在入門 Webpack 的時候一定和小弟一樣會遇到一個瓶頸， 就是覺得 webpack.config.js 不知道怎麼設定！ 沒有人手把手帶的話實在要花很多時間去理解它的設定規則… Laravel mix 提供一系列優雅的 api，讓你可以更直觀的做 webpack 的設定， 真的是降低了很大的 webpack 使用門檻！ ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:0:0","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"在 laravel 中使用 laravel mix ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:1:0","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"建立專案 new a project composer create-project laravel/laravel --prefer-dist laravelmix-demo 執行 npm install 來安裝 laravel 預設會用到的 node packages (如：lodash, bootstrap, webpack, babel…) npm install 執行 npm run 可以查看有哪些 scripts 可以使用 (設定在 package.json) npm run dev：npm run development的縮寫，進行一次打包 npm run watch：監聽檔案更動，即時執行打包 npm run watch-poll：在某些系統上，npm run watch 並不總是有效的，此時可以嘗試使用此指令 npm run prod：npm run production的縮寫，進行一次打包並壓縮(minify)程式碼 ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:1:1","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"資料夾結構 此篇文章的 laravel 版本是 laravel 8 laravel 8 預設的 webpack.mix.js 設定如下： mix.js('resources/js/app.js', 'public/js') .postCss('resources/css/app.css', 'public/css', [ // ]); 在這個設定下執行過一次打包後(npm run dev)，資料夾結構如下： 📂 public 📂 js app.js：打包後的js 📂 css app.css：打包後的css 📂 resources 📂 css app.css：預設的來源css 📂 js app.js：預設的來源js，會 require bootstrap.js bootstrap.js：此 bootstrap 非彼 bootstrap，而是指一個用來引入/設定所有需要套件的js(如：axios, lodash…) webpack.mix.js：使用 laravel mix 提供的 api 進行 webpack 的設定 ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:1:2","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"laravel mix api 說明 下為 laravel 8 預設的 webpack.mix.js 設定，這段設定相當直觀，就是 將 resources/js/app.js 打包到 public/js 資料夾中 (public/js/app.js) 將 resources/css/app.css 打包到 public/css 資料夾中 (public/css/app.css) webpack.mix.js mix.js('resources/js/app.js', 'public/js') .postCss('resources/css/app.css', 'public/css'); PostCSS？ PostCss 是一個使用 JavaScript 轉換 CSS 的工具，可以做的事情很多，如： autoprefixer 加入各家瀏覽器的前綴詞 (-webkit-、-moz- 等…)。 postcss-preset-env 將modern css轉為目前主流瀏覽器所能支援的語法 Linters 當有語法錯誤時，console 錯誤訊息 相較於 sass, scss 等預處理器（Preprocessors），PostCSS 同時扮演後處理器（Postprocessors）的角色 預處理器：讓開發者撰寫一些類似 CSS 的語法，再轉為瀏覽器能懂的 CSS 後處理器：寫好的 CSS 經過擴充功能（plugin）的後製處理，將特定功能轉成瀏覽器能懂的指令。 /* laravel 8 預設用 PostCSS 編譯 app.css， 所以當我在 resources/css/app.css 寫入： */ input.test { appearance: slider-horizontal; } /* 經過打包後，public/css/app.css 會呈現： */ input.test { -webkit-appearance: slider-horizontal; -moz-appearance: slider-horizontal; appearance: slider-horizontal; } /* 這是由於 PostCSS 的 autoprefixer 為其加上了各瀏覽器的前綴詞 */ 將多個檔案合併打包至一個檔案 mix.styles([ 'resources/css/card.css', 'resources/css/button.css' ], 'public/css/card-and-btn.css'); mix.scripts([ 'resources/js/disscount.js', 'resources/js/product.js' ], 'public/js/cart.js'); 也可以用 import 的方式進行合併檔案 css 可以用 postcss-import javascript 可以用 es6 module 語法 ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:1:3","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"參考資料 Getting Started with Laravel Mix, Part 2: Setup PostCSS | Summer。桑莫。夏天 ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:2:0","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"練習檔案 https://github.com/hdsbook/laravelmix-demo.git ","date":"2020-10-07","objectID":"/20201007-laravel-mix-note/:3:0","tags":["laravel","webpack"],"title":"Laravel mix 學習筆記","uri":"/20201007-laravel-mix-note/"},{"categories":["modernWeb"],"content":"webpack + babel","date":"2020-10-07","objectID":"/20201007-webpack-note/","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"什麼是 Webpack ？ 隨著時代的演進，現代前端的開發不再只是 html、css、js 三大元素。 現代前端多了很多新技術與框架，如 scss、pug、Vue、React、ES6 javascript、CSS3 等… 但是我們的瀏覽器(如：古早味的IE)可能還是只看得懂舊版的 html、css、js， 所以我們需要一個第三方的打包工具，來幫我們編譯這些新技術程式碼， 轉換為瀏覽器看得懂的最原始的三大元素 (html、css、js)， 並且在打包的過程中可以進行壓縮，優化程式碼的效能。 而這些第三方的打包工具中(如：Webpack, gulp.js…)，最廣為人知，被許多框架採用的， 就是 Webpack。 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:1:0","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"什麼是 Babel？ Babel 可以幫我們把高版本 (ECMAScript 6 以上) 的 javascript，降轉成舊版本等效的 js 讓瀏覽器能夠去解讀。 也就是說如果只用 Webpack 打包 javascript，部份瀏覽器還是會因為其中用了 es6 的語法而無法運行。 若在 Webpack 上掛載 Babel 模組，就可以在打包的過程也進行 js 版本的降轉。 一般我們使用 Webpack ，都會掛載 babel 來為我們降轉 js 版本， 使打包出來的檔案可以被大部份瀏覽器解讀 (理論上可以支持到 ie 9)， 在 laravel 中，laravel-mix 所用的 webpack 就預設整合了 babel 模組。 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:2:0","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"Webpack 的部署 Webpack 建立在 node.js 的開發環境下，所以電腦需先裝好 node.js， 而 nvm(Node Version Manager) 是用來 安裝/使用 不同版本的 node.js 的工具， 因此若要在 mac 上安裝 node.js ，可以 先用 homebrew 安裝 nvm，再用 nvm 安裝 node.js，步驟記錄如下： ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:0","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"1. 安裝 Node.js (參考自：Install NVM On Mac With Brew) 若電腦中已有安裝 node，先取消安裝之 brew uninstall --ignore-dependencies node brew uninstall --force node 安裝 nvm brew update brew install nvm 安裝後，它會提示你建立一個資料夾 mkdir ~/.nvm 並在~/.bash_profile 中寫入： export NVM_DIR=~/.nvm source $(brew --prefix nvm)/nvm.sh 執行 source ~/.bash_profile nvm install [版本號，不用輸入得很精確] nvm install 12 查看 node.js 版本 nvm ls 切換 node.js 版本 nvm use 12 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:1","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"2. 安裝 Webpack npm i -g webpack npm i -g webpack-dev-server npm i -g webpack-cli ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:2","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"3. 部署 Webpack 建立資料夾並初始化 mkdir webpack-demo cd webpack-demo npm init -y 安裝 webpack-cli npm install webpack webpack-cli --save-dev 新增 index.js 與 webpack.config.js webpack-demo/src/index.js const arr = ['1', '2', '3']; arr.map(item =\u003e console.log(item)); webpack-demo/webpack.config.js const path = require('path'); module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'index.bundle.js' }, }; 上面的設定就是要把 ./src/index.js 打包到 ./dist/index.bundle.js 設定好便可執行 webpack 指令進行打包，打包後，檔案結構如下圖所示 webpack 到目前為止，因為我們只有用webpack進行打包，還沒有掛載 babel 做js版本的降轉， 所以如果仔細去看打包出來的 index.bundle.js，裡面的內容還是維持 index.js 中 es6 的語法 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:3","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"4. 掛載 Babel 模組 安裝 babel-loader (參考自官方文件 babel-loader)，於 webpack-demo 資料夾執行： npm install -D babel-loader @babel/core @babel/preset-env -D 與 --save-dev 同義，就是要把模組資訊加到 package.json 中 於 webpack.config.js 中加入模組設定，加入後 webpack.config.js 如下 const path = require('path'); module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'index.bundle.js' }, module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } ] } }; 此時再執行 webpack 打包，出來的 index.bundle.js 就會是經過降轉的 js 了 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:4","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"5. webpack 指令說明 webpack 指令其實可以指定 mode (development/production)，和給一個 watch 參數使其能自動打包 development mode 為開發階段所用，為提高打包效率，不進行壓縮； production mode 為上線專案所用，進行壓縮以提高程式執行效能，但打包過程需要較多時間。 當給予 –watch 參數時，webpack 會監聽檔案的 onchange，當檔案發生變動時，自動進行打包。 webpack --mode development 進行一次打包 (不進行壓縮) webpack --mode production 進行一次打包 (進行壓縮，較耗效能) webpack --mode development --watch 持續監聽檔案，若有更動，即時進行打包 (不進行壓縮) ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:5","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"6. npm run script 設定 在 package.json 中，有一個很方便的 scripts 設定，讓我們可以簡化執行 webpack 的指令 打開 package.json，在 scripts 設定中加入： \"scripts\": { \"watch\": \"webpack --mode development --watch\", \"start\": \"webpack --mode development\", \"deploy\": \"webpack --mode production\" }, 這樣當我們想執行 webpack --mode development --watch，就可以直接執行npm run watch； 想執行 webpack --mode development，就執行 npm run start，以此類推… 開發階段，用 npm run watch 部署到正試機，用 npm run deploy ","date":"2020-10-07","objectID":"/20201007-webpack-note/:3:6","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"參考資料 Webpack 前端自動化開發超入門 ","date":"2020-10-07","objectID":"/20201007-webpack-note/:4:0","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"練習檔案 https://github.com/hdsbook/webpack-demo ","date":"2020-10-07","objectID":"/20201007-webpack-note/:5:0","tags":["javascript","webpack"],"title":"Webpack 學習筆記","uri":"/20201007-webpack-note/"},{"categories":["modernWeb"],"content":"es6 features","date":"2020-10-06","objectID":"/20201006-es6-note/","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"es6 features 最近透過兩門線上課程學習現代前端的知識，在此紀錄一下對於 es6 語法的觀念及細節 ","date":"2020-10-06","objectID":"/20201006-es6-note/:0:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"let 與 const var 的作用範圍是 scope(作用域) function scope global scope (不是在函式中，就是 global scope) let, const 的作用範圍是 block (用大括號來介定它的範圍) 大括孤，中間有程式碼，稱為 block const 是不能被更改(reassign) 的變數 (可以換家具，不可以搬家) 常用來宣告元素實體。物件、陣列、函式也常以 const 宣告 只有在 object、array 的情況下可以塞東西，但不可以改變型別，所以在嚴謹的情況下會使用 const 來宣告物件或陣列 const 可視為不能 reassign 的 let var 與 function 有 hoisting 的特性，let 與 const 沒有 let 與 const 可以完全取代 var var num = 1; if (true) { // 變數的作用範圍在 global scope var name = \"tony\"; // let 是用大括號來介定它的範圍 // 暫時性的變數用 let 宣告 (local 變數) let num = 2; // const 是不能被更改的變數，且作用範圍是local，常用在宣告 document.getElementById() const selector = \"a\"; // selector = \"b\"; console.log(selector); } console.log(name); console.log(num); // 1 // const 只有在 object 和 array 的情況下可以塞東西，但不可以改變型別 // 所以在嚴謹的情況下會使用 const 來宣告物件或陣列 const a = {}; a.name = \"Mike\"; a.name = \"Judy\"; // a = []; // 不被允許 console.log(a); const b = []; b.push(1); // b = 2; // 不被允許 console.log(b); ","date":"2020-10-06","objectID":"/20201006-es6-note/:1:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"解構賦值 ","date":"2020-10-06","objectID":"/20201006-es6-note/:2:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"陳列解構 考慮一陣列： const arr = [1, 2, 3]; // first = 1, second = 2 const [first, second] = arr; // first = 1, second = 2, third=3, fourth=4(取預設值) const [first, second, third, fourth=4] = arr; // second = 2 const [, second] = arr; // third = 3 const [,, third] = arr; 利用陣列解構達到變數交換 [a, b] = [b, a]; 取得剩餘陣列值 const nums = [1, 2, 3, 4]; const [first, ...others] = nums; // first === 1, nums =\u003e [2, 3, 4] ","date":"2020-10-06","objectID":"/20201006-es6-note/:2:1","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"物件解構 const user = { name: \"Mike\", age: 12, address: \"Taiwan\", }; // 可以重新命名(age =\u003e userAge)，可以指定預設值(sex='male') const { name, age:userAge, address, sex='male' } = user; console.log(name, userAge, address, sex); // 直接將物件放到物件中，物件會在物件中自動進行解構(以變數名稱為其key值) const userData = { user, // 會自動解構成 =\u003e user: {name: \"Mike\", ... } }; console.log(userData); ","date":"2020-10-06","objectID":"/20201006-es6-note/:2:2","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"解構函式參數 function distance(point) { const {x, y} = point; return Math.sqrt(x*x + y*y); } 可以直接在參數解構，並亦可給予預設值 function distance({x, y=0}) { return Math.sqrt(x*x + y*y); } ","date":"2020-10-06","objectID":"/20201006-es6-note/:2:3","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"物件縮寫 (Object shorthand) ","date":"2020-10-06","objectID":"/20201006-es6-note/:3:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"屬性縮寫 let x = y = 0; const point = { x: x, y: y } 可以縮寫成 const point = {x, y} ","date":"2020-10-06","objectID":"/20201006-es6-note/:3:1","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"計算屬性 let key = 'price'; const blog = { }; blog[key] = 100; 可用[]包住變數代入key值，[]中可放入計算式 let key = 'price'; const blog = { [key]: 100, ['discount_' + key]: 80 } ","date":"2020-10-06","objectID":"/20201006-es6-note/:3:2","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"函式縮寫 const options = { mounted: function () { }, } 消去冒號與function關鍵字，可縮寫成： const options = { mounted() { }, } ","date":"2020-10-06","objectID":"/20201006-es6-note/:3:3","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"箭頭函式運算式 const Add = function (a, b) { return a + b; } // 省略 function 關鍵字，加上鍵頭，變成： const Add = (a, b) =\u003e { return a + b; } // 當回傳只有一行時，可進一步簡化成： const Add = (a, b) =\u003e a + b; // 當函數參數只有一個的時候，可以省略參數的小括孤 const Double = a =\u003e a * 2; 箭頭函式中沒有this，this會往上一層找 若要取得dom元素實體本身，則要透過 e.target 取得 document.getElementById(\"aLink1\").addEventListener(\"click\", function () { console.log(this); // 指向 #aLink1 }); document.getElementById(\"aLink2\").addEventListener(\"click\", (e) =\u003e { // 箭頭函式中沒有this，this會往上一層找 console.log(this); // 指向 window // 若要取得dom元素實體本身，則要透過 e.target 取得 console.log(e.target); // 指向 #aLink2 }); 箭頭函數的參數可以指定預設值 const ArrayToStr = (arr = [1, 1, 1, 1]) =\u003e { return arr.map((item) =\u003e item + \"\"); } ","date":"2020-10-06","objectID":"/20201006-es6-note/:4:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"函數的 this 指向誰，取決於如何執行函式 this的定義？ this是函式的context(情境)，就是指函式執行的情境、函式被呼叫的方法 function jump() { console.log(this); } // 1. 直接執行 (this 為 gloabal 或 window) jump(); // this 指向 window // 2. 作為物件的成員函式執行 (this 為 該物件) var a = {}; a.jump = jump; a.jump(); // this 指向 a // 3. 綁定 dom 事件 (this 為 發出事件的DOM) btn.addEventListener('click', jump); // this 指向 #btn dom 物件 // 當用箭頭函式宣告，則不管怎麼執行，this都是上層的this (箭頭函數沒有自己的 this) const jump = () =\u003e { console.log(this) } ","date":"2020-10-06","objectID":"/20201006-es6-note/:5:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"字串模版 // 透過字串模版，可以更方面的進行字串與變數的串接、換行 const add = (name, age) =\u003e { return ` Hi 我叫${name}， 我今年${age}歲 `; }; console.log(add(\"Mike\", 12)); ","date":"2020-10-06","objectID":"/20201006-es6-note/:6:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"ES module ./js/Tools.js const Add = (a, b) =\u003e { return a + b; }; // 可以 export 很多東西出去，但是default只能有一個 export default Add; // 要用 export 丟出去的只能用 const 變數丟出去 (named export) export const Name = \"mike\"; export const age = 12; export const Minus = (a, b) =\u003e { return a - b; } index.html \u003c!-- 用 type=\"module\" 告訴瀏覽器這邊是屬於 es6 module 的用法，讓它認得 import 指令 --\u003e \u003cscript type=\"module\"\u003e // 除了 default 的東西，其它要用解構的方式 import 進來 import Add, { Name as userName, age, Minus } from \"./js/Tools.js\"; console.log(Add(1, 2)); console.log(userName); console.log(age); console.log(Minus(5, 3)); \u003c/script\u003e ","date":"2020-10-06","objectID":"/20201006-es6-note/:7:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":["modernWeb"],"content":"Class class Dog extends Animal { constructor() { this.age = 0; } bark() { console.log('woof'); } } const dog = new Dog(); class Dog extends Animal { this.age = 0; bark() =\u003e console.log('woof'); } const dog = new Dog(); 參考資料： 2020 Vue3 專業職人 | 入門篇 (預購中) - HiSKIO 跨領域學程式 | 專業程式線上課程平台 | 嗨 程式技能 React 16 完全精通 - 從原理到大量實戰應用 - HiSKIO 跨領域學程式 | 專業程式線上課程平台 | 嗨 程式技能 ","date":"2020-10-06","objectID":"/20201006-es6-note/:8:0","tags":["javascript","es6"],"title":"ES6 語法學習筆記","uri":"/20201006-es6-note/"},{"categories":null,"content":"ace-code-editor, showdown, github-markdown-css","date":"2020-07-15","objectID":"/20200715-markdown-editor-by-ace-and-showdown/","tags":["markdown","javascript"],"title":"Markdown editor with vscode keybinding","uri":"/20200715-markdown-editor-by-ace-and-showdown/"},{"categories":null,"content":"ace-code-editor, showdown, github-markdown-css 此篇文章分享如何簡單建立一個好用的 markdown editor 將會用到兩個 js 套件：ace-code-editor 和 showdown markdown 呈現的 css 則套用 github-markdown-css 那就開始吧 ","date":"2020-07-15","objectID":"/20200715-markdown-editor-by-ace-and-showdown/:0:0","tags":["markdown","javascript"],"title":"Markdown editor with vscode keybinding","uri":"/20200715-markdown-editor-by-ace-and-showdown/"},{"categories":null,"content":"1. git init \u0026 npm init mkdir showdown-practice cd showdown-practice git init npm init ","date":"2020-07-15","objectID":"/20200715-markdown-editor-by-ace-and-showdown/:1:0","tags":["markdown","javascript"],"title":"Markdown editor with vscode keybinding","uri":"/20200715-markdown-editor-by-ace-and-showdown/"},{"categories":null,"content":"2. npm install npm install jquery npm install bootstrap npm install showdown npm install github-markdown-css npm install ace-builds ","date":"2020-07-15","objectID":"/20200715-markdown-editor-by-ace-and-showdown/:2:0","tags":["markdown","javascript"],"title":"Markdown editor with vscode keybinding","uri":"/20200715-markdown-editor-by-ace-and-showdown/"},{"categories":null,"content":"3. index.html \u003clink rel=\"stylesheet\" href=\"node_modules/github-markdown-css/github-markdown.css\"\u003e \u003clink rel=\"stylesheet\" href=\"node_modules/bootstrap/dist/css/bootstrap.min.css\"\u003e \u003cstyle\u003e body { height: 100vh; } \u003c/style\u003e \u003cdiv class=\"d-flex justify-content-around align-items-center h-100 p-5\"\u003e \u003cdiv class=\"flex-fill h-100 m-3 mb-5\"\u003e \u003ch3\u003eInput markdown\u003c/h3\u003e \u003cdiv id=\"markdownArea\" class=\"border rounded w-100 h-100\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"flex-fill h-100 m-3 mb-5\"\u003e \u003ch3\u003eOutput Html\u003c/h3\u003e \u003cdiv id=\"outputArea\" class=\"markdown-body border rounded w-100 h-100 p-3 overflow-auto\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript src=\"node_modules/showdown/dist/showdown.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"node_modules/jquery/dist/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"node_modules/ace-builds/src-min/ace.js\"\u003e\u003c/script\u003e \u003cscript\u003e $(function() { var editor = initEditor(\"markdownArea\", \"outputArea\"); }); function initEditor(inputId, outputId) { let editor = ace.edit(inputId); // editor.setReadOnly(true); // 是否唯讀 editor.setTheme(\"ace/theme/dawn\"); // 主題樣式 editor.setShowPrintMargin(false); // 不要顯示右方 margin editor.setKeyboardHandler(\"ace/keyboard/vscode\"); // 快捷鍵類型 (keybinding) editor.session.setMode(\"ace/mode/markdown\"); // 內容語言類型 editor.session.on('change', function(delta) { // delta.start, delta.end, delta.lines, delta.action var markdownText = editor.getValue(); var html = markdownToHtml(markdownText); $(\"#\" + outputId).html(html); }); return editor; } function markdownToHtml(text) { var converter = new showdown.Converter(); return converter.makeHtml(text); } \u003c/script\u003e 以上為最簡化的程式，詳細可再到我的 github 上查看 ","date":"2020-07-15","objectID":"/20200715-markdown-editor-by-ace-and-showdown/:3:0","tags":["markdown","javascript"],"title":"Markdown editor with vscode keybinding","uri":"/20200715-markdown-editor-by-ace-and-showdown/"},{"categories":["loveItDoc"],"content":"好用的提示框 shortcode","date":"2020-07-01","objectID":"/0-loveit-admonition-note/","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":" admonition(警告/訓詞) shortcode 提供 12 種樣式讓你可以在文章中放入各種提示 Markdown 或 HTML 也都可以寫入 admonition ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:0:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Note Note Some note tips… {{\u003c admonition note \"Note\" \u003e}} Some note tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:1:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Abstract Abstract Some abstract tips… {{\u003c admonition \"Abstract\" \u003e}} Some abstract tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:2:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Info Info Some info tips… {{\u003c admonition info \"Info\" \u003e}} Some info tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:3:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Tip Tip Some tip tips… {{\u003c admonition tip \"Tip\" \u003e}} Some tip tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:4:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Success Success Some success tips… {{\u003c admonition success \"Success\" \u003e}} Some success tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:5:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Question Question Some question tips… {{\u003c admonition question \"Question\" \u003e}} Some question tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:6:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Warning Warning Some warning tips… {{\u003c admonition warning \"Warning\" \u003e}} Some warning tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:7:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Failure Failure Some failure tips… {{\u003c admonition failure \"Failure\" \u003e}} Some failure tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:8:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Danger Danger Some danger tips… {{\u003c admonition danger \"Danger\" \u003e}} Some danger tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:9:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Bug Bug Some bug tips… {{\u003c admonition bug \"Bug\" \u003e}} Some bug tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:10:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Example Example Some example tips… {{\u003c admonition * \"Example\" \u003e}} Some example tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:11:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"Quote Quote Some quote tips… {{\u003c admonition quote \"Quote\" \u003e}} Some quote tips... {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:12:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":["loveItDoc"],"content":"admonition 有三個參數可以設定，你可以選擇以下兩種寫法 {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} {{\u003c /admonition \u003e}} OR {{\u003c admonition tip \"This is a tip\" false \u003e}} {{\u003c /admonition \u003e}} ","date":"2020-07-01","objectID":"/0-loveit-admonition-note/:13:0","tags":["LoveIt"],"title":"Hugo LoveIt admonition","uri":"/0-loveit-admonition-note/"},{"categories":null,"content":"簡歷 See the Pen 動畫互動網頁特效入門 Project 1：個人履歷 by hdsbook (@hdsbook) on CodePen. ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"網站使用的 Hugo 主題：LoveIt  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \" Hugo Theme LoveIt ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":[],"content":"我的 server 是在 Linode 上租的 網域名稱則是在 Goddady 上註冊的 雖然可以在 Goddady 上面做 domain name 對應 ip 的托管 我選擇在 Linode 上托管我的網域名稱 此篇文章分享的是在 Linode上設定子網域 ","date":"2019-04-27","objectID":"/20190427-apache-subdomain/:0:0","tags":["apache"],"title":"設定子網域","uri":"/20190427-apache-subdomain/"},{"categories":[],"content":"什麼是子網域 什麼是子網域(subdomain)呢 以小弟的網站來說，www.hdsbook.com .com 為第一層級網域名稱 Top Level Domain (TLD) hdsbook 為第二層級網域名稱 Second Level Domain (SLD) 通常我們跟域名註冊商 (如Goddady) 註冊的就是這兩層 domain name 而最前面的 www 就是 subdomain, 中文可以稱其為 (主/子網域) 我們最常見的 www.google.com (估狗首頁)，mail.google.com(信箱)，drive.google.com(雲端硬碟)… 其實就是子網域的應用啦 一個域名其實可以擁有很多個子網域(www, mail, drive…)，通常以 www 做為主網站 所以呢，如果你有多個網站在經營，而這些網站可能都只是同一間公司的不同事業體 則你可以選擇設定不同的子網域名稱，就不用多花錢註冊那麼多的網域名稱啦 ","date":"2019-04-27","objectID":"/20190427-apache-subdomain/:0:1","tags":["apache"],"title":"設定子網域","uri":"/20190427-apache-subdomain/"},{"categories":[],"content":"如何設定子網域 那麼怎麼設定呢, 假設你的域名稱為 xxxx.com 首先，在你的 server 上故好三件事 Step 1. 放上你的網站 ex: /var/www/www.xxxx.com /var/www/test.xxxx.com Step 2. apache2.conf \u003cDirectory /var/www/www.xxxx.com/\u003e AllowOverride AllRequire all granted \u003c/Directory\u003e \u003cDirectory /var/www/test.xxxx.com/\u003e AllowOverride AllRequire all granted \u003c/Directory\u003e Step 3. virtual host 新增 www.xxxx.com.conf 和 test.xxxx.com.conf, 內容格式如下 # www.xxxx.com.conf \u003cVirtualHost *:80\u003e DocumentRoot /var/www/www.xxxx.com/ ServerName www.xxxx.com \u003c/VirtualHost\u003e # test.xxxx.com.conf \u003cVirtualHost *:80\u003e DocumentRoot /var/www/test.xxxx.com/ ServerName www.xxxx.com \u003c/VirtualHost\u003e 執行以下指令： a2ensite www.xxxx.com.conf a2ensite test.xxxx.com.conf sudo service apache2 restart Step 4 Linode 托管設定 最後來到你的 Linode 做最後的 dns 托管設定：(登入後進入你租的server然後點選domains) 把 www.xxxx.com 和 test.xxxx.com 都加到 A record 然後你會看到你的子網域都被加到 a record 其實有些網站會教你非主網域 加 CNAME record 不過其實是差不多的意思，只是 A record 是直接對應到 IP CNAME 則是先對應到其它dns，再對應到其對應的IP 詳細差別可以看這篇文章：https://support.dnsimple.com/articles/differences-between-a-cname-alias-url/ 小弟兩個都嘗試過，其實都是有用的 若你是要加 CNAME record，www.xxxx.com還是要先加到 A record，然後 加 CNAME record 時 ，alias to 要填寫www.xxxx.com 做完已上設定，最多大概等一小時，就可以用這兩個網址連到你的網站啦 p.s. 其實 Goddady 就可以做子網域設定 但是每次我在Linode做完子網域設定，等5分鍾就有了 超有效率，不知道是不是跟 server 位置和他們的托管 server 距離有關係 總之在 Goddady 設定完要等一到兩天，這種不安全感是滿討厭的 所以自此我都是讓Linode托管我的 dns 如果讀者也想租Linode server，可以選在日本或新加坡的主機 感覺和台灣比較近連線速度也有差？(還是心裡作用) ","date":"2019-04-27","objectID":"/20190427-apache-subdomain/:0:2","tags":["apache"],"title":"設定子網域","uri":"/20190427-apache-subdomain/"},{"categories":[],"content":"Step1: Install Homebrew 官網：https://brew.sh/index_zh-tw $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" ","date":"2019-04-09","objectID":"/20190409-php-xdebug-vscode-mac/:1:0","tags":["php"],"title":"Xdebug + PHP + Vscode on Mac","uri":"/20190409-php-xdebug-vscode-mac/"},{"categories":[],"content":"Step2: Install php by homebrew $ brew install php@7.2 裝好後，可以下以下指令，會指示你接下來的動作 $ brew info php@7.2 To enable PHP in Apache add the following to httpd.conf and restart Apache: LoadModule php7_module /usr/local/opt/php@7.2/lib/httpd/modules/libphp7.so \u003cFilesMatch \\.php$\u003e SetHandler application/x-httpd-php \u003c/FilesMatch\u003e Finally, check DirectoryIndex includes index.php DirectoryIndex index.php index.html The php.ini and php-fpm.ini file can be found in: /usr/local/etc/php/7.2/ php@7.2 is keg-only, which means it was not symlinked into /usr/local, because this is an alternate version of another formula. If you need to have php@7.2 first in your PATH run: echo 'export PATH=\"/usr/local/opt/php@7.2/bin:$PATH\"' \u003e\u003e ~/.bash_profile echo 'export PATH=\"/usr/local/opt/php@7.2/sbin:$PATH\"' \u003e\u003e ~/.bash_profile For compilers to find php@7.2 you may need to set: export LDFLAGS=\"-L/usr/local/opt/php@7.2/lib\" export CPPFLAGS=\"-I/usr/local/opt/php@7.2/include\" To have launchd start php@7.2 now and restart at login: brew services start php@7.2 Or, if you don't want/need a background service you can just run: php-fpm 依上列提示設定就序後，重開 terminal 可下 php -v 檢查是否有成功裝好 php 若成功，則下： $ sudo apachectl restart 重啟 apache 後，應該就可以用新的 php 運行你的本機網站了 ","date":"2019-04-09","objectID":"/20190409-php-xdebug-vscode-mac/:2:0","tags":["php"],"title":"Xdebug + PHP + Vscode on Mac","uri":"/20190409-php-xdebug-vscode-mac/"},{"categories":[],"content":"Step3: Install Pear 官網：https://pear.php.net/manual/en/installation.getting.php $ curl -O http://pear.php.net/go-pear.phar $ sudo php -d detect_unicode=0 go-pear.phar 接著進入輸入模式，做以下設定： 輸入 1 輸入 /usr/local/pear 輸入 4 輸入 /usr/local/bin 完成上列兩項設調整後，接著直接按 Enter 繼續安裝即可 完成安裝後，可下 pear version 看是否成功安裝 ","date":"2019-04-09","objectID":"/20190409-php-xdebug-vscode-mac/:3:0","tags":["php"],"title":"Xdebug + PHP + Vscode on Mac","uri":"/20190409-php-xdebug-vscode-mac/"},{"categories":[],"content":"Step4: Install xdebug by pecl 官網：https://xdebug.org/docs/install $ pecl install xdebug 安裝的最後應該會 log 安裝的位置，請趕快記錄下來，我的位置為 /usr/local/Cellar/php@7.2/7.2.16/pecl/20170718/xdebug.so 這個位址要寫到 php.ini, 若忘記或不知道 php.ini 的位置，可再下 brew info php@7.2 查看 我的在 /usr/local/etc/php/7.2/php.ini ","date":"2019-04-09","objectID":"/20190409-php-xdebug-vscode-mac/:4:0","tags":["php"],"title":"Xdebug + PHP + Vscode on Mac","uri":"/20190409-php-xdebug-vscode-mac/"},{"categories":[],"content":"Step5: Config php.ini 打開 php.ini 後，加上下列： # zend_extension=\"xdebug.so\" ; 可能會預設有這行，但這行並無用，要用絕對位址如下一行所示 zend_extension=\"/usr/local/Cellar/php@7.2/7.2.16/pecl/20170718/xdebug.so\" # xdebug.remote_port=9001 ; 可自行訂別的 port，預設為 9000 xdebug.profiler_enable = on xdebug.remote_enable = 1 xdebug.remote_autostart = 1 xdebug.remote_host = \"localhost\" 編輯完下 sudo apachectl restart 重啟 apache ","date":"2019-04-09","objectID":"/20190409-php-xdebug-vscode-mac/:5:0","tags":["php"],"title":"Xdebug + PHP + Vscode on Mac","uri":"/20190409-php-xdebug-vscode-mac/"},{"categories":[],"content":"Step6: Vscode 安裝 extension: PHP DEBUG (app key: felixfbecker.php-debug) 打開 settings.json 並加上php executable path： \"php.executablePath\": \"/usr/local/Cellar/php@7.2/7.2.16/bin/php\" 最後於要使用 xdebug 的專案下切到 debug 頁籤點左上方的設定圖樣開啟 launch.json { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Listen for XDebug\", \"type\": \"php\", \"request\": \"launch\", \"port\": 9000 }, { \"name\": \"Launch currently open script\", \"type\": \"php\", \"request\": \"launch\", \"program\": \"${file}\", \"cwd\": \"${fileDirname}\", \"port\": 9000 } ] } 然後就可以下斷點，f5開始debug啦~ ","date":"2019-04-09","objectID":"/20190409-php-xdebug-vscode-mac/:6:0","tags":["php"],"title":"Xdebug + PHP + Vscode on Mac","uri":"/20190409-php-xdebug-vscode-mac/"},{"categories":[],"content":"php 現今已經有非常多不同的 framework 像是早期很多人用的Codeigniter，到現在最受歡迎的Laravel PHP FIG (全名 PHP Framework Interoperability Group)，成立於2009年 目的在於建立各框架的統一規範 包含編碼風格、以及對於各 framework 都會遇到的問題，提供建議的解決方案 各框架遵循其規範以增加彼此的共通性，降低學習成本，提高程式的優美度和維護性 PSR (PHP Standard Recommendation) 由 PHP-FIG 所制定 目前 FIG官方網站 已經約有 12 條規則發佈 其中 PSR-1 PSR-2 是針對 Coding Style 所作的規範 其規範內容可以到官方網站查看 或是參考點燈坊翻譯的中文版 (PSR-2 Coding Style) 此篇文章後面僅針對 php-cs-fixer 在 mac 的 vscode 上應用做介紹 往往在不同公司維護網站時，因為編碼的習慣不同 對程式的閱讀體驗很差 現在了解了 PSR 對 Coding Style 的規範 對於編碼風格終於可以有個依據 但是其實我很懶，不太想死記熟悉每一條規則 當然希望有套件(php-cs-fixer)可以幫忙自動完成這項作業 以下紀錄在 mac 環境的 vscode 上配置 php-cs-fixer 過程中可能會遇到的問題 ","date":"2019-03-16","objectID":"/20190316-psr2-coding-style-phpcs/:0:0","tags":["php"],"title":"PSR-2 Coding Style","uri":"/20190316-psr2-coding-style-phpcs/"},{"categories":[],"content":"Step1：下載 php-cs-fixer 首先假設你的 mac 已經裝有 composer，在 terminal 下 $ composer global require --dev friendsofphp/php-cs-fixe 點燈坊的文章在四年前，提供的php-cs-fixer是舊版的(fabpot/php-cs-fixer)，安裝後還是會提示你改用新版的 若你已經載了舊版的，要更新成新版只要remove舊版的再require 新版的就可以，如下： composer remove fabpot/php-cs-fixer composer global require --dev friendsofphp/php-cs-fixer 等載好 php-cs-fixer ，可以在 terminal 下指令確認是否有作用 $ php-cs-fixer --version 成功的話應該會有訊息告知 php-cs-fixer 的版本訊息 若出現 command not found 訊息，應該是你的環境變數還沒設定 以下是 mac 上設定環境變數的方式： $ touch ~/.bash_profile; $ open ~/.bash_profile; 在 .bash_profile 的環境變數中加入(:~/.composer/vendor/bin)，若你的.bash_profile為空檔案，編輯如下 export PATH=[你的其它PATH]:~/.composer/vendor/bin; 關閉編輯器後執行(若你本來就有.bash_profile，可以不用執行) $ source ~/.bash_profile; ","date":"2019-03-16","objectID":"/20190316-psr2-coding-style-phpcs/:1:0","tags":["php"],"title":"PSR-2 Coding Style","uri":"/20190316-psr2-coding-style-phpcs/"},{"categories":[],"content":"Step2：Vscode 安裝 extension：php cs fixer vscode 安裝好 php cs fixer 後 (extension_id：junstyle.php-cs-fixer，開發者：junstyle) 做以下基本設定： { \"php-cs-fixer.onsave\": true, \"php-cs-fixer.executablePath\": \"${extensionPath}/php-cs-fixer.phar\", \"php-cs-fixer.rules\": \"@PSR2\", } php-cs-fixer.onsave 為儲存時自動修正，若不想要可以不加 其預設是打大括號時自動修正(“php-cs-fixer.autoFixByBracket”: true) 完成以上設定，在編程時 vscode 就會自動幫你修正符合 PSR-2 的 Coding Style 啦 ","date":"2019-03-16","objectID":"/20190316-psr2-coding-style-phpcs/:2:0","tags":["php"],"title":"PSR-2 Coding Style","uri":"/20190316-psr2-coding-style-phpcs/"},{"categories":[],"content":"Facebook的按讚分享功能配置起來真的很簡單 設定好 og meta，放置要顯示fb like share的div，最後加上js的部分就好了 ","date":"2018-10-30","objectID":"/20181030-facebook-like/:0:0","tags":[],"title":"簡單就能讓網站擁有按讚功能","uri":"/20181030-facebook-like/"},{"categories":[],"content":"Step1 Set og meta tag \u003cmeta property=\"og:url\" content=\"{{ url()-\u003ecurrent() }}\" /\u003e \u003cmeta property=\"og:type\" content=\"article\" /\u003e \u003cmeta property=\"og:title\" content=\"{{ $blog-\u003etitle }}\" /\u003e \u003cmeta property=\"og:description\" content=\"{{ $blog-\u003esubtitle }}\" /\u003e \u003cmeta property=\"og:image\" content=\"{{ $blog-\u003eimage }}\" /\u003e ","date":"2018-10-30","objectID":"/20181030-facebook-like/:0:1","tags":[],"title":"簡單就能讓網站擁有按讚功能","uri":"/20181030-facebook-like/"},{"categories":[],"content":"Step2 add fb-like div \u003cdiv class=\"fb-like\" data-href=\"{{ url()-\u003ecurrent() }}\" data-layout=\"standard\" data-action=\"like\" data-size=\"small\" data-show-faces=\"true\" data-share=\"true\"\u003e\u003c/div\u003e ","date":"2018-10-30","objectID":"/20181030-facebook-like/:0:2","tags":[],"title":"簡單就能讓網站擁有按讚功能","uri":"/20181030-facebook-like/"},{"categories":[],"content":"Step3 Javascript \u003cscript\u003e(function(d, s, id) { var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = 'https://connect.facebook.net/zh_TW/sdk.js#xfbml=1\u0026version=v3.2'; fjs.parentNode.insertBefore(js, fjs); }(document, 'script', 'facebook-jssdk'));\u003c/script\u003e 參考 : https://developers.facebook.com/docs/plugins/like-button?locale=zh_TW# ","date":"2018-10-30","objectID":"/20181030-facebook-like/:0:3","tags":[],"title":"簡單就能讓網站擁有按讚功能","uri":"/20181030-facebook-like/"},{"categories":["laravelPlugins"],"content":"繼上一篇 CKeditor部署 我花了好一些時間研究CKeditor要如何上傳圖片到我的server 此篇是來分享 laravel 5.6 部署 CKEditor + CKFinder 的方式 網路上有很多教學直接從官網下載 [原生 php版本] 的ckfinder下來配置 但是其實配置的過程中會遇到滿多問題的 其實已經有熱心的Contributor發布了laravel專用的ckfinder套件 改寫了原本ckfinder的結構，讓ckfinder更容易在laravel上配置 事實上官方網站的說明文件也有提供這個套件的連結 網址: https://github.com/ckfinder/ckfinder-laravel-package ","date":"2018-10-29","objectID":"/20181029-laravel-ckeditor-ckfinder/:0:0","tags":["ckeditor","ckfinder","laravel"],"title":"Laravel CKEditor + CKFinder","uri":"/20181029-laravel-ckeditor-ckfinder/"},{"categories":["laravelPlugins"],"content":"Step1 Require ckfinder with composer 打開終端機，來到專案資料夾底下，下以下指令 composer require ckfinder/ckfinder-laravel-package php artisan ckfinder:download 這兩個指令會把ckfinder的套件載到vendor資料夾下 ","date":"2018-10-29","objectID":"/20181029-laravel-ckeditor-ckfinder/:0:1","tags":["ckeditor","ckfinder","laravel"],"title":"Laravel CKEditor + CKFinder","uri":"/20181029-laravel-ckeditor-ckfinder/"},{"categories":["laravelPlugins"],"content":"Step2 Publish ckfinder assets php artisan vendor:publish --tag=ckfinder 這個指令會將 ckfinder 的 plugin assets 發布到 public/js/ckfinder 底下， config.php 則會發佈為 config/ckfinder.php ","date":"2018-10-29","objectID":"/20181029-laravel-ckeditor-ckfinder/:0:2","tags":["ckeditor","ckfinder","laravel"],"title":"Laravel CKEditor + CKFinder","uri":"/20181029-laravel-ckeditor-ckfinder/"},{"categories":["laravelPlugins"],"content":"Step3 Make directory userfiles mkdir -m 777 public/userfiles 建立userfiles資料夾並且賦予777權限 這個資料夾為ckfinder預設上傳檔案的位置 ","date":"2018-10-29","objectID":"/20181029-laravel-ckeditor-ckfinder/:0:3","tags":["ckeditor","ckfinder","laravel"],"title":"Laravel CKEditor + CKFinder","uri":"/20181029-laravel-ckeditor-ckfinder/"},{"categories":["laravelPlugins"],"content":"Step4 Set authentication \u003c?php // config/ckfinder.php $config['authentication'] = function () { return true; // return Auth::check(); }; $config['csrfProtection'] = false; 編輯config/ckfinder.php，暫時將認證的部分改成直接回傳true 但若你的專案已經有會員認證功能，希望只允許登入會員上傳檔案 這邊直接寫 return Auth::check(); 就可以摟 ~ 並將 csrfProtection 設為 false ","date":"2018-10-29","objectID":"/20181029-laravel-ckeditor-ckfinder/:0:4","tags":["ckeditor","ckfinder","laravel"],"title":"Laravel CKEditor + CKFinder","uri":"/20181029-laravel-ckeditor-ckfinder/"},{"categories":["laravelPlugins"],"content":"Step5 Set Route (browse, request) \u003c?php // routes\\web.php Route::any('/ckfinder/examples/{example?}', 'CKFinderController@examplesaction') -\u003ename('ckfinder_examples'); Route::any('/ckfinder/connector', 'CKFinderController@requestAction') -\u003ename('ckfinder_connector'); Route::any('/ckfinder/browser', 'CKFinderController@browserAction') -\u003ename('ckfinder_browser'); 以上路由都是從GitHub範例copy過來稍微改寫的， 配合接下來的 Step6可以把一些範例demo放到自己的網站上 第一個路由是用來瀏覽範例的路由，第二個主要是上傳檔案用，第三個則是打開ckfinder瀏覽器的路由 ","date":"2018-10-29","objectID":"/20181029-laravel-ckeditor-ckfinder/:0:5","tags":["ckeditor","ckfinder","laravel"],"title":"Laravel CKEditor + CKFinder","uri":"/20181029-laravel-ckeditor-ckfinder/"},{"categories":["laravelPlugins"],"content":"Step6 Controller, View 從 https://github.com/ckfinder/ckfinder-laravel-package 下載上面的範例，裡面有Controller 和 View 可以將Controller和View如下放到你的專案中 Controller =\u003e app\\Http\\Controllers\\CKFinderController.php resources/views └- ckfinder └- samples/… └- browser.php └- setup.php 若如上配置，記得要改掉 CKFinderController 的 namespace \u003c?php namespace App\\Http\\Controllers; ","date":"2018-10-29","objectID":"/20181029-laravel-ckeditor-ckfinder/:0:6","tags":["ckeditor","ckfinder","laravel"],"title":"Laravel CKEditor + CKFinder","uri":"/20181029-laravel-ckeditor-ckfinder/"},{"categories":["laravelPlugins"],"content":"Step7 Disable csrf verify on connector route \u003c?php // app\\Http\\Middleware\\VerifyCsrfToken.php protected $except = [ 'ckfinder/*' ]; 這個設定是為了讓檔案上傳的POST可以不用經過csrf的認證 做到這邊，你應該可以透過 [your site url]/ckfinder/examples/ckeditor 來看到許多範例已經配置到你的網站 如本站的 http://hdsbook.com/ckfinder/examples/ckeditor 並且範例上的ckeditor上傳圖片的功能會正常運作 (上列本站的ckfinder範例網址的上傳功能有加入會員權限認證所以可能會無法正常瀏覽或上傳檔案) 剩下的就是你可以到 views/ckfinder/samples 底下去參考各範例的js是怎麼寫的 這邊也簡單提供把CKeditor與CKfinder結合的寫法 // \u003ctextarea id='editor'\u003e\u003c/textarea\u003e var editor = CKEDITOR.replace('editor'); CKFinder.setupCKEditor(editor); 別忘了，在你的master layout中要引入 ckfinder.js 喔 \u003cscript src=\"{{ asset('js/ckfinder/ckfinder.js') }}\"\u003e\u003c/script\u003e ","date":"2018-10-29","objectID":"/20181029-laravel-ckeditor-ckfinder/:0:7","tags":["ckeditor","ckfinder","laravel"],"title":"Laravel CKEditor + CKFinder","uri":"/20181029-laravel-ckeditor-ckfinder/"},{"categories":[],"content":"其實我很少用ajax的方式來POST檔案 一般真的遇到需要POST檔案的時候 多會用form來達成，如下 \u003cform action=\"\u003c?= base_url().'/image.upload' ?\u003e\" method=\"POST\"\u003e \u003cinput type=\"file\" name=\"img\" /\u003e \u003c/form\u003e 只是一次在 開發 CI 框架的網站遇到特殊情況 希望能用ajax的方式將檔案POST到後端處理 卻發現 ajax 在 POST 檔案時並不是那麼簡明 於是寫下此篇也為自己做個紀錄 首先，宣告一個全域變數 files 監聽我的 input var files; $(function(){ $(\"input[name='img']\").on('change', function(e) { files = e.target.files; }); }); 再來是ajax送出的部分 function upload_image() { var data = new FormData(); if ( files.length == 0 ) return false; data.append('img', files[0]); $.ajax({ url: base_url() + \"/image_upload\", type: \"POST\", data: data, processData: false, // Don't process the files contentType: false, // Set content type to false dataType: \"json\", success: function(){ ... } }); } 注意! 這邊一定要設定 processData 和 contentType 兩個屬性為false 否則ajax送出時就會出錯 最後php後端直接用 $_FILES[‘img’] 來取得檔案即可 其他詳細可參考下列文章 https://abandon.ie/notebook/simple-file-uploads-using-jquery-ajax ","date":"2018-10-10","objectID":"/20181010-ajax-post-file/:0:0","tags":["php"],"title":"Ajax Post file","uri":"/20181010-ajax-post-file/"},{"categories":[],"content":"時常在做資料處理的時候，會遇到如下的需求 \u003c?php // 原陣列 $users= array( 0 =\u003e array('user_id' =\u003e 31, 'name' =\u003e 'Tom', 'age' =\u003e 20), 1 =\u003e array('user_id' =\u003e 38, 'name' =\u003e 'Tony', 'age' =\u003e 28), 2 =\u003e array('user_id' =\u003e 45, 'name' =\u003e 'Jenny', 'age' =\u003e 17) ) // 欲轉換成以 user_id 為 索引，如下 $uesrs_info = array( 31 =\u003e array('user_id' =\u003e 31, 'name' =\u003e 'Tom', 'age' =\u003e 20), 38 =\u003e array('user_id' =\u003e 38, 'name' =\u003e 'Tony', 'age' =\u003e 28), 45 =\u003e array('user_id' =\u003e 45, 'name' =\u003e 'Jenny', 'age' =\u003e 17) ) 如上所示，欲創造一個陣列，將其改為以某一個column(user_id)為索引 以方便後續如果要調用某一個 $user 時 我只要有user_id，便可以透過這個array來取得該user的其他資訊 不用再用迴圈或是 array_keys 來查找搜尋 為了實踐上述的需求，最直觀的作法可能是 \u003c?php $users_info = array(); foreach( $users as $key =\u003e $value) { $users_info[$value['user_id']] = $value; } 這樣的方式實在是有點冗長 後來發現 Laravel 的 collection 有一個 pluck method \u003c?php $users = User()::all()-\u003epluck('user_id')-\u003etoArray(); 這個pluck真的是太方便了，上列程式碼即是將撈取出來的資料以user_id為索引並轉換為陣列 但並不是每次都是在laravel或是有collection套件的環境下開發 所以其實php有一個非常簡單的函式可以達到一樣的效果，那就是array_column \u003c?php // 原陣列 $users= array( 0 =\u003e array('user_id' =\u003e 31, 'name' =\u003e 'Tom', 'age' =\u003e 20), 1 =\u003e array('user_id' =\u003e 38, 'name' =\u003e 'Tony', 'age' =\u003e 28), 2 =\u003e array('user_id' =\u003e 45, 'name' =\u003e 'Jenny', 'age' =\u003e 17) ) $uesrs_1 = array_column($users, 'user_id'); // [ 0 =\u003e 31, 1 =\u003e 38, 2 =\u003e 45] $users_2 = array_column($users, 'name', 'user_id'); // [ 31 =\u003e 'Tom', 38 =\u003e 'Tony', 45 =\u003e 'Jenny' ] $users_3 = array_column($users, null, 'user_id'); /* array( 31 =\u003e array('user_id' =\u003e 31, 'name' =\u003e 'Tom', 'age' =\u003e 20), 38 =\u003e array('user_id' =\u003e 38, 'name' =\u003e 'Tony', 'age' =\u003e 28), 45 =\u003e array('user_id' =\u003e 45, 'name' =\u003e 'Jenny', 'age' =\u003e 17) ) */ 以上，更多php array應用之道可參見以下文章 https://laravel-china.org/articles/14159/the-way-to-use-the-php-array ","date":"2018-10-09","objectID":"/20181009-php-pluck-array/:0:0","tags":["php"],"title":"PHP pluck array","uri":"/20181009-php-pluck-array/"},{"categories":[],"content":"這篇文章是來分享如何在 selectpicker 中顯示 bootstrap 的標籤 註: 在Bootstrap4中，badge 和 label被合併到 badge 中，本篇用的是bootstrap4 這個問題是來自於我想要做一個下拉 select 來選擇我的文章標籤要用哪些， 並且我希望在option裡面顯示出標籤，代碼如下 : \u003cselect class='selectpicker'\u003e \u003coption\u003e\u003cspan class='badge badge-pill badge-secondary'\u003ejavascript\u003c/span\u003e\u003c/option\u003e \u003c/select\u003e 但是在selectpicker初始化後，option中的內容並沒有預期性的套上標籤的class 而是被一個 text 的 class 取代掉 螫騰了許久，終於讓我找到解決的方式 \u003cselect class='selectpicker' data-showContent='true'\u003e \u003coptiondata-content=\"\u003cspan class='badge badge-pill badge-secondary'\u003ejavascript\u003c/span\u003e\"\u003e \u003c/option\u003e \u003c/select\u003e ","date":"2018-09-29","objectID":"/20180929-badges-in-selectpicker/:0:0","tags":["javascript"],"title":"Show badges in Selectpicker","uri":"/20180929-badges-in-selectpicker/"},{"categories":["laravelPlugins"],"content":"我在Laravel 5.6 部署 CKeditor，此篇僅做最基本快速部署的筆記 ","date":"2018-09-18","objectID":"/20180918-laravel56-ckeditor/:0:0","tags":["javascript","ckeditor"],"title":"Laravel 5.6 CKeditor 部署","uri":"/20180918-laravel56-ckeditor/"},{"categories":["laravelPlugins"],"content":"Step1: Download CKeditor 到 官方網站 下載 Fullpage 的 CKeditor (with easy Image) 20181029 更新: 後來我發現easy Image是付費的功能，不付費會有時間和上傳圖片數量的限制 所以建議還是一開始就不要勾選那個easy Image 之後會有介紹透過CKFinder讓CKEditor有上傳圖片的功能 ","date":"2018-09-18","objectID":"/20180918-laravel56-ckeditor/:0:1","tags":["javascript","ckeditor"],"title":"Laravel 5.6 CKeditor 部署","uri":"/20180918-laravel56-ckeditor/"},{"categories":["laravelPlugins"],"content":"Step2: Put to asset folder 放到 laravel project 的 public 資料夾下 ( ex: public/plugins/ckeditor ) ","date":"2018-09-18","objectID":"/20180918-laravel56-ckeditor/:0:2","tags":["javascript","ckeditor"],"title":"Laravel 5.6 CKeditor 部署","uri":"/20180918-laravel56-ckeditor/"},{"categories":["laravelPlugins"],"content":"Step3: codesnippet, markdown 感覺未來我會希望我的 CKeditor 能有程式碼片段及支援 markdown 的功能 於是我到官網另外下載了兩個plugins For codesnippet ( 連結 ) For markdown ( 連結 ) 這兩個plugins下載完放到原 ckeditor 底下的 plugins 資料夾底下即可 ( i.e. public/plugins/ckeditor/plugins/ ) ","date":"2018-09-18","objectID":"/20180918-laravel56-ckeditor/:0:3","tags":["javascript","ckeditor"],"title":"Laravel 5.6 CKeditor 部署","uri":"/20180918-laravel56-ckeditor/"},{"categories":["laravelPlugins"],"content":"Step4: Edit config file as follow CKEDITOR.editorConfig = function( config ) { config.tabSpaces = 4; config.extraPlugins= 'easyimage,codesnippet,markdown'; config.codeSnippet_theme = \"monokai\"; }; 第一行是使 CKeditor 可以吃 tab spaces，並且指定為四個空格，才不會想寫一些程式碼片段時按下 tab時，cursor focus 到下一個欄位或是button 第二行是使 CKeditor 載入一些我們額外下載的套件: codesnippet, markdown 最後第三行只是要設定我的 css style of codesnippet 為 monokai ","date":"2018-09-18","objectID":"/20180918-laravel56-ckeditor/:0:4","tags":["javascript","ckeditor"],"title":"Laravel 5.6 CKeditor 部署","uri":"/20180918-laravel56-ckeditor/"},{"categories":["laravelPlugins"],"content":"Step5: Link css js to layouts \u003cscript src=\"{{ asset('plugins/ckeditor/ckeditor.js') }}\"\u003e\u003c/script\u003e \u003cscript src=\"{{ asset('plugins/ckeditor/config.js') }}\"\u003e\u003c/script\u003e \u003cscript src=\"{{ asset('plugins/ckeditor/adapters/jquery.js') }}\"\u003e\u003c/script\u003e {{-- ckeditor jquery adapter --}} \u003cscript src=\"{{ asset('plugins/ckeditor/plugins/codesnippet/lib/highlight/highlight.pack.js') }}\"\u003e\u003c/script\u003e {{-- CKeditor codesnippet monokai css --}} \u003clink rel=\"stylesheet\" href=\"{{ asset('plugins/ckeditor/plugins/codesnippet/lib/highlight/styles/monokai.css') }}\"\u003e ","date":"2018-09-18","objectID":"/20180918-laravel56-ckeditor/:0:5","tags":["javascript","ckeditor"],"title":"Laravel 5.6 CKeditor 部署","uri":"/20180918-laravel56-ckeditor/"},{"categories":["laravelPlugins"],"content":"Step6: 應用 把 input 變成 ckeditor 的方法大概有以下兩種 基本款: 此方法的參數只能為 id CKEDITOR.replace('editor_id'); // 對應的input需要設定對應的 id \u003cinput id=\"editor_id\" /\u003e CKeditor jquery adapter: 若想用jquery的方式抓取特定input，那麼上一步驟須確實引入 ckeditor jquery adapter $('.editor_class').ckeditor(); // \u003cinput class='editor_class' /\u003e 然後欲存取ckeditor的value，用 jquery 的 .val() 即可 至少我這樣取好像還沒有出過問題，不像另一款editor tinymce 還要用getContent() ","date":"2018-09-18","objectID":"/20180918-laravel56-ckeditor/:0:6","tags":["javascript","ckeditor"],"title":"Laravel 5.6 CKeditor 部署","uri":"/20180918-laravel56-ckeditor/"},{"categories":["laravelPlugins"],"content":"Step 7: Apply codesnippet css style to front page 這最後也是我卡了一陣子的問題 就是當我把存在DB的內容顯示到前端時 // laravel 顯示HTML內容要用 {!! !!} {!! $blog-\u003econtent !!} 我的程式碼片段並沒有monokai的黑底style，但是我的css明明也都link進來了呀 後來才找到這個解決方法 // CKeditor css apply to front page hljs.initHighlightingOnLoad(); // Or you can write in page ready function as follow $(function(){ $('pre code').each(function (i, block) { hljs.highlightBlock(block); }); }); 參考來源 : https://stackoverflow.com/questions/51325778/hljs-inithighlightingonload-does-not-render-the-page-directly ","date":"2018-09-18","objectID":"/20180918-laravel56-ckeditor/:0:7","tags":["javascript","ckeditor"],"title":"Laravel 5.6 CKeditor 部署","uri":"/20180918-laravel56-ckeditor/"}]